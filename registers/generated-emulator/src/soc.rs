// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 2ec4914686d656467fae8ff40ee7da03ee6f5ec3
//
#[allow(unused_imports)]
use tock_registers::interfaces::{Readable, Writeable};
pub trait SocPeripheral {
    fn set_dma_ram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<emulator_bus::Ram>>) {}
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_cptra_hw_error_fatal(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraHwErrorFatal::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_hw_error_fatal(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraHwErrorFatal::Register,
        >,
    ) {
    }
    fn read_cptra_hw_error_non_fatal(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraHwErrorNonFatal::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_hw_error_non_fatal(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraHwErrorNonFatal::Register,
        >,
    ) {
    }
    fn read_cptra_fw_error_fatal(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_error_fatal(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_fw_error_non_fatal(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_error_non_fatal(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_hw_error_enc(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_hw_error_enc(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_fw_error_enc(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_error_enc(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_fw_extended_error_info(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_extended_error_info(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_boot_status(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_boot_status(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_flow_status(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraFlowStatus::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_flow_status(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraFlowStatus::Register,
        >,
    ) {
    }
    fn read_cptra_reset_reason(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraResetReason::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_cptra_security_state(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraSecurityState::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_cptra_mbox_valid_axi_user(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_mbox_valid_axi_user(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_mbox_axi_user_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_mbox_axi_user_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
        >,
    ) {
    }
    fn read_cptra_trng_valid_axi_user(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_trng_valid_axi_user(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_trng_axi_user_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_trng_axi_user_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
        >,
    ) {
    }
    fn read_cptra_trng_data(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_trng_data(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_trng_ctrl(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::CptraTrngCtrl::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_trng_ctrl(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraTrngCtrl::Register,
        >,
    ) {
    }
    fn read_cptra_trng_status(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraTrngStatus::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_trng_status(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraTrngStatus::Register,
        >,
    ) {
    }
    fn read_cptra_fuse_wr_done(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraFuseWrDone::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_fuse_wr_done(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraFuseWrDone::Register,
        >,
    ) {
    }
    fn read_cptra_timer_config(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_timer_config(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_bootfsm_go(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraBootfsmGo::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_bootfsm_go(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraBootfsmGo::Register,
        >,
    ) {
    }
    fn read_cptra_dbg_manuf_service_reg(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_dbg_manuf_service_reg(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_clk_gating_en(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraClkGatingEn::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_clk_gating_en(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraClkGatingEn::Register,
        >,
    ) {
    }
    fn read_cptra_generic_input_wires(&mut self) -> emulator_types::RvData {
        0
    }
    fn read_cptra_generic_output_wires(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_generic_output_wires(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_hw_rev_id(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::CptraHwRevId::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_cptra_fw_rev_id(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_rev_id(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_hw_config(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::CptraHwConfig::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_cptra_wdt_timer1_en(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraWdtTimer1En::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_wdt_timer1_en(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraWdtTimer1En::Register,
        >,
    ) {
    }
    fn read_cptra_wdt_timer1_ctrl(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraWdtTimer1Ctrl::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_wdt_timer1_ctrl(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraWdtTimer1Ctrl::Register,
        >,
    ) {
    }
    fn read_cptra_wdt_timer1_timeout_period(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_wdt_timer1_timeout_period(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_wdt_timer2_en(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraWdtTimer2En::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_wdt_timer2_en(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraWdtTimer2En::Register,
        >,
    ) {
    }
    fn read_cptra_wdt_timer2_ctrl(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraWdtTimer2Ctrl::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_wdt_timer2_ctrl(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraWdtTimer2Ctrl::Register,
        >,
    ) {
    }
    fn read_cptra_wdt_timer2_timeout_period(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_wdt_timer2_timeout_period(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_wdt_status(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraWdtStatus::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_wdt_status(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraWdtStatus::Register,
        >,
    ) {
    }
    fn read_cptra_fuse_valid_axi_user(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fuse_valid_axi_user(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_fuse_axi_user_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_fuse_axi_user_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraXxxxAxiUserLock::Register,
        >,
    ) {
    }
    fn read_cptra_wdt_cfg(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_wdt_cfg(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_i_trng_entropy_config_0(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraItrngEntropyConfig0::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_i_trng_entropy_config_0(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraItrngEntropyConfig0::Register,
        >,
    ) {
    }
    fn read_cptra_i_trng_entropy_config_1(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::CptraItrngEntropyConfig1::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_i_trng_entropy_config_1(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraItrngEntropyConfig1::Register,
        >,
    ) {
    }
    fn read_cptra_rsvd_reg(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_rsvd_reg(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_hw_capabilities(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_hw_capabilities(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_fw_capabilities(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_fw_capabilities(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_cap_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::CptraXxxxxxxk::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_cap_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraXxxxxxxk::Register,
        >,
    ) {
    }
    fn read_cptra_owner_pk_hash(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_cptra_owner_pk_hash(&mut self, _val: emulator_types::RvData) {}
    fn read_cptra_owner_pk_hash_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::CptraXxxxxxxk::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_cptra_owner_pk_hash_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::CptraXxxxxxxk::Register,
        >,
    ) {
    }
    fn write_fuse_uds_seed(&mut self, _val: emulator_types::RvData) {}
    fn write_fuse_field_entropy(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_key_manifest_pk_hash(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_key_manifest_pk_hash(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_key_manifest_pk_hash_mask(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_key_manifest_pk_hash_mask(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_fmc_key_manifest_svn(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_fmc_key_manifest_svn(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_runtime_svn(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_runtime_svn(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_anti_rollback_disable(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::FuseAntiRollbackDisable::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_fuse_anti_rollback_disable(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::FuseAntiRollbackDisable::Register,
        >,
    ) {
    }
    fn read_fuse_idevid_cert_attr(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_idevid_cert_attr(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_idevid_manuf_hsm_id(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_idevid_manuf_hsm_id(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_lms_revocation(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_lms_revocation(&mut self, _val: emulator_types::RvData) {}
    fn read_fuse_mldsa_revocation(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::FuseMldsaRevocation::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_fuse_mldsa_revocation(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::FuseMldsaRevocation::Register,
        >,
    ) {
    }
    fn read_fuse_soc_stepping_id(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::FuseSocSteppingId::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_fuse_soc_stepping_id(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::FuseSocSteppingId::Register,
        >,
    ) {
    }
    fn read_fuse_manuf_dbg_unlock_token(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_fuse_manuf_dbg_unlock_token(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_caliptra_base_addr_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_caliptra_base_addr_l(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_caliptra_base_addr_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_caliptra_base_addr_h(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_mci_base_addr_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_mci_base_addr_l(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_mci_base_addr_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_mci_base_addr_h(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_recovery_ifc_base_addr_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_recovery_ifc_base_addr_l(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_recovery_ifc_base_addr_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_recovery_ifc_base_addr_h(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_otp_fc_base_addr_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_otp_fc_base_addr_l(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_otp_fc_base_addr_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_otp_fc_base_addr_h(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_uds_seed_base_addr_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_uds_seed_base_addr_l(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_uds_seed_base_addr_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_uds_seed_base_addr_h(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_prod_debug_unlock_auth_pk_hash_reg_bank_offset(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_prod_debug_unlock_auth_pk_hash_reg_bank_offset(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_ss_num_of_prod_debug_unlock_auth_pk_hashes(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_num_of_prod_debug_unlock_auth_pk_hashes(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_debug_intent(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::SsDebugIntent::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_ss_strap_generic(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_strap_generic(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_dbg_manuf_service_reg_req(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::SsDbgManufServiceRegReq::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_ss_dbg_manuf_service_reg_req(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::SsDbgManufServiceRegReq::Register,
        >,
    ) {
    }
    fn read_ss_dbg_manuf_service_reg_rsp(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::SsDbgManufServiceRegRsp::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_ss_dbg_manuf_service_reg_rsp(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::SsDbgManufServiceRegRsp::Register,
        >,
    ) {
    }
    fn read_ss_soc_dbg_unlock_level(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_soc_dbg_unlock_level(&mut self, _val: emulator_types::RvData) {}
    fn read_ss_generic_fw_exec_ctrl(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_ss_generic_fw_exec_ctrl(&mut self, _val: emulator_types::RvData) {}
    fn write_internal_obf_key(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_iccm_lock(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::InternalIccmLock::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_internal_iccm_lock(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::InternalIccmLock::Register,
        >,
    ) {
    }
    fn read_internal_fw_update_reset(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::InternalFwUpdateReset::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_internal_fw_update_reset(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::InternalFwUpdateReset::Register,
        >,
    ) {
    }
    fn read_internal_fw_update_reset_wait_cycles(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::InternalFwUpdateResetWaitCycles::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_internal_fw_update_reset_wait_cycles(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::InternalFwUpdateResetWaitCycles::Register,
        >,
    ) {
    }
    fn read_internal_nmi_vector(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_nmi_vector(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_hw_error_fatal_mask(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::InternalHwErrorFatalMask::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_internal_hw_error_fatal_mask(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::InternalHwErrorFatalMask::Register,
        >,
    ) {
    }
    fn read_internal_hw_error_non_fatal_mask(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::InternalHwErrorNonFatalMask::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_internal_hw_error_non_fatal_mask(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::InternalHwErrorNonFatalMask::Register,
        >,
    ) {
    }
    fn read_internal_fw_error_fatal_mask(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_fw_error_fatal_mask(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_fw_error_non_fatal_mask(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_fw_error_non_fatal_mask(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_rv_mtime_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_rv_mtime_l(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_rv_mtime_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_rv_mtime_h(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_rv_mtimecmp_l(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_rv_mtimecmp_l(&mut self, _val: emulator_types::RvData) {}
    fn read_internal_rv_mtimecmp_h(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_internal_rv_mtimecmp_h(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_global_intr_en_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::GlobalIntrEnT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_global_intr_en_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::GlobalIntrEnT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_error_intr_en_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::ErrorIntrEnT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_error_intr_en_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::ErrorIntrEnT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_notif_intr_en_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::NotifIntrEnT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_notif_intr_en_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::NotifIntrEnT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_error_global_intr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::GlobalIntrT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_global_intr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::GlobalIntrT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_internal_intr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::ErrorIntrT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_error_internal_intr_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::ErrorIntrT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_notif_internal_intr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::soc::bits::NotifIntrT::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_notif_internal_intr_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::NotifIntrT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_error_intr_trig_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::ErrorIntrTrigT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_error_intr_trig_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::ErrorIntrTrigT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_notif_intr_trig_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::NotifIntrTrigT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_intr_block_rf_notif_intr_trig_r(
        &mut self,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::soc::bits::NotifIntrTrigT::Register,
        >,
    ) {
    }
    fn read_intr_block_rf_error_internal_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_internal_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_error_inv_dev_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_inv_dev_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_error_cmd_fail_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_cmd_fail_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_error_bad_fuse_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_bad_fuse_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_error_iccm_blocked_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_iccm_blocked_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_error_mbox_ecc_unc_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_mbox_ecc_unc_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_error_wdt_timer1_timeout_intr_count_r(
        &mut self,
    ) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_wdt_timer1_timeout_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_error_wdt_timer2_timeout_intr_count_r(
        &mut self,
    ) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_error_wdt_timer2_timeout_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_notif_cmd_avail_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_cmd_avail_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_notif_mbox_ecc_cor_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_mbox_ecc_cor_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_notif_debug_locked_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_debug_locked_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_notif_scan_mode_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_scan_mode_intr_count_r(&mut self, _val: emulator_types::RvData) {}
    fn read_intr_block_rf_notif_soc_req_lock_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_soc_req_lock_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_notif_gen_in_toggle_intr_count_r(&mut self) -> emulator_types::RvData {
        0
    }
    fn write_intr_block_rf_notif_gen_in_toggle_intr_count_r(
        &mut self,
        _val: emulator_types::RvData,
    ) {
    }
    fn read_intr_block_rf_error_internal_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_inv_dev_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_cmd_fail_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_bad_fuse_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_iccm_blocked_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_mbox_ecc_unc_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_wdt_timer1_timeout_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_error_wdt_timer2_timeout_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_cmd_avail_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_mbox_ecc_cor_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_debug_locked_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_scan_mode_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_soc_req_lock_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_intr_block_rf_notif_gen_in_toggle_intr_count_incr_r(
        &mut self,
    ) -> emulator_bus::ReadWriteRegister<
        u32,
        registers_generated::soc::bits::IntrCountIncrT::Register,
    > {
        emulator_bus::ReadWriteRegister::new(0)
    }
}
pub struct SocBus {
    pub periph: Box<dyn SocPeripheral>,
}
impl emulator_bus::Bus for SocBus {
    fn read(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
    ) -> Result<emulator_types::RvData, emulator_bus::BusError> {
        if addr & 0x3 != 0 || size != emulator_types::RvSize::Word {
            return Err(emulator_bus::BusError::LoadAddrMisaligned);
        }
        match addr {
            0..4 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_hw_error_fatal().reg.get(),
            )),
            4..8 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_hw_error_non_fatal().reg.get(),
            )),
            8..0xc => Ok(self.periph.read_cptra_fw_error_fatal()),
            0xc..0x10 => Ok(self.periph.read_cptra_fw_error_non_fatal()),
            0x10..0x14 => Ok(self.periph.read_cptra_hw_error_enc()),
            0x14..0x18 => Ok(self.periph.read_cptra_fw_error_enc()),
            0x18..0x38 => Ok(self.periph.read_cptra_fw_extended_error_info()),
            0x38..0x3c => Ok(self.periph.read_cptra_boot_status()),
            0x3c..0x40 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_flow_status().reg.get(),
            )),
            0x40..0x44 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_reset_reason().reg.get(),
            )),
            0x44..0x48 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_security_state().reg.get(),
            )),
            0x48..0x5c => Ok(self.periph.read_cptra_mbox_valid_axi_user()),
            0x5c..0x70 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_mbox_axi_user_lock().reg.get(),
            )),
            0x70..0x74 => Ok(self.periph.read_cptra_trng_valid_axi_user()),
            0x74..0x78 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_trng_axi_user_lock().reg.get(),
            )),
            0x78..0xa8 => Ok(self.periph.read_cptra_trng_data()),
            0xa8..0xac => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_trng_ctrl().reg.get(),
            )),
            0xac..0xb0 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_trng_status().reg.get(),
            )),
            0xb0..0xb4 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_fuse_wr_done().reg.get(),
            )),
            0xb4..0xb8 => Ok(self.periph.read_cptra_timer_config()),
            0xb8..0xbc => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_bootfsm_go().reg.get(),
            )),
            0xbc..0xc0 => Ok(self.periph.read_cptra_dbg_manuf_service_reg()),
            0xc0..0xc4 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_clk_gating_en().reg.get(),
            )),
            0xc4..0xcc => Ok(self.periph.read_cptra_generic_input_wires()),
            0xcc..0xd4 => Ok(self.periph.read_cptra_generic_output_wires()),
            0xd4..0xd8 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_hw_rev_id().reg.get(),
            )),
            0xd8..0xe0 => Ok(self.periph.read_cptra_fw_rev_id()),
            0xe0..0xe4 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_hw_config().reg.get(),
            )),
            0xe4..0xe8 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_timer1_en().reg.get(),
            )),
            0xe8..0xec => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_timer1_ctrl().reg.get(),
            )),
            0xec..0xf4 => Ok(self.periph.read_cptra_wdt_timer1_timeout_period()),
            0xf4..0xf8 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_timer2_en().reg.get(),
            )),
            0xf8..0xfc => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_timer2_ctrl().reg.get(),
            )),
            0xfc..0x104 => Ok(self.periph.read_cptra_wdt_timer2_timeout_period()),
            0x104..0x108 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_status().reg.get(),
            )),
            0x108..0x10c => Ok(self.periph.read_cptra_fuse_valid_axi_user()),
            0x10c..0x110 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_fuse_axi_user_lock().reg.get(),
            )),
            0x110..0x118 => Ok(self.periph.read_cptra_wdt_cfg()),
            0x118..0x11c => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_i_trng_entropy_config_0().reg.get(),
            )),
            0x11c..0x120 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_i_trng_entropy_config_1().reg.get(),
            )),
            0x120..0x128 => Ok(self.periph.read_cptra_rsvd_reg()),
            0x128..0x12c => Ok(self.periph.read_cptra_hw_capabilities()),
            0x12c..0x130 => Ok(self.periph.read_cptra_fw_capabilities()),
            0x130..0x134 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_cap_lock().reg.get(),
            )),
            0x140..0x170 => Ok(self.periph.read_cptra_owner_pk_hash()),
            0x170..0x174 => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_owner_pk_hash_lock().reg.get(),
            )),
            0x260..0x290 => Ok(self.periph.read_fuse_key_manifest_pk_hash()),
            0x290..0x2b0 => Ok(self.periph.read_fuse_key_manifest_pk_hash_mask()),
            0x2b4..0x2b8 => Ok(self.periph.read_fuse_fmc_key_manifest_svn()),
            0x2b8..0x2c8 => Ok(self.periph.read_fuse_runtime_svn()),
            0x2c8..0x2cc => Ok(emulator_types::RvData::from(
                self.periph.read_fuse_anti_rollback_disable().reg.get(),
            )),
            0x2cc..0x32c => Ok(self.periph.read_fuse_idevid_cert_attr()),
            0x32c..0x33c => Ok(self.periph.read_fuse_idevid_manuf_hsm_id()),
            0x340..0x344 => Ok(self.periph.read_fuse_lms_revocation()),
            0x344..0x348 => Ok(emulator_types::RvData::from(
                self.periph.read_fuse_mldsa_revocation().reg.get(),
            )),
            0x348..0x34c => Ok(emulator_types::RvData::from(
                self.periph.read_fuse_soc_stepping_id().reg.get(),
            )),
            0x34c..0x35c => Ok(self.periph.read_fuse_manuf_dbg_unlock_token()),
            0x500..0x504 => Ok(self.periph.read_ss_caliptra_base_addr_l()),
            0x504..0x508 => Ok(self.periph.read_ss_caliptra_base_addr_h()),
            0x508..0x50c => Ok(self.periph.read_ss_mci_base_addr_l()),
            0x50c..0x510 => Ok(self.periph.read_ss_mci_base_addr_h()),
            0x510..0x514 => Ok(self.periph.read_ss_recovery_ifc_base_addr_l()),
            0x514..0x518 => Ok(self.periph.read_ss_recovery_ifc_base_addr_h()),
            0x518..0x51c => Ok(self.periph.read_ss_otp_fc_base_addr_l()),
            0x51c..0x520 => Ok(self.periph.read_ss_otp_fc_base_addr_h()),
            0x520..0x524 => Ok(self.periph.read_ss_uds_seed_base_addr_l()),
            0x524..0x528 => Ok(self.periph.read_ss_uds_seed_base_addr_h()),
            0x528..0x52c => Ok(self
                .periph
                .read_ss_prod_debug_unlock_auth_pk_hash_reg_bank_offset()),
            0x52c..0x530 => Ok(self
                .periph
                .read_ss_num_of_prod_debug_unlock_auth_pk_hashes()),
            0x530..0x534 => Ok(emulator_types::RvData::from(
                self.periph.read_ss_debug_intent().reg.get(),
            )),
            0x5a0..0x5b0 => Ok(self.periph.read_ss_strap_generic()),
            0x5c0..0x5c4 => Ok(emulator_types::RvData::from(
                self.periph.read_ss_dbg_manuf_service_reg_req().reg.get(),
            )),
            0x5c4..0x5c8 => Ok(emulator_types::RvData::from(
                self.periph.read_ss_dbg_manuf_service_reg_rsp().reg.get(),
            )),
            0x5c8..0x5d0 => Ok(self.periph.read_ss_soc_dbg_unlock_level()),
            0x5d0..0x5e0 => Ok(self.periph.read_ss_generic_fw_exec_ctrl()),
            0x620..0x624 => Ok(emulator_types::RvData::from(
                self.periph.read_internal_iccm_lock().reg.get(),
            )),
            0x624..0x628 => Ok(emulator_types::RvData::from(
                self.periph.read_internal_fw_update_reset().reg.get(),
            )),
            0x628..0x62c => Ok(emulator_types::RvData::from(
                self.periph
                    .read_internal_fw_update_reset_wait_cycles()
                    .reg
                    .get(),
            )),
            0x62c..0x630 => Ok(self.periph.read_internal_nmi_vector()),
            0x630..0x634 => Ok(emulator_types::RvData::from(
                self.periph.read_internal_hw_error_fatal_mask().reg.get(),
            )),
            0x634..0x638 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_internal_hw_error_non_fatal_mask()
                    .reg
                    .get(),
            )),
            0x638..0x63c => Ok(self.periph.read_internal_fw_error_fatal_mask()),
            0x63c..0x640 => Ok(self.periph.read_internal_fw_error_non_fatal_mask()),
            0x640..0x644 => Ok(self.periph.read_internal_rv_mtime_l()),
            0x644..0x648 => Ok(self.periph.read_internal_rv_mtime_h()),
            0x648..0x64c => Ok(self.periph.read_internal_rv_mtimecmp_l()),
            0x64c..0x650 => Ok(self.periph.read_internal_rv_mtimecmp_h()),
            0x800..0x804 => Ok(emulator_types::RvData::from(
                self.periph.read_intr_block_rf_global_intr_en_r().reg.get(),
            )),
            0x804..0x808 => Ok(emulator_types::RvData::from(
                self.periph.read_intr_block_rf_error_intr_en_r().reg.get(),
            )),
            0x808..0x80c => Ok(emulator_types::RvData::from(
                self.periph.read_intr_block_rf_notif_intr_en_r().reg.get(),
            )),
            0x80c..0x810 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_global_intr_r()
                    .reg
                    .get(),
            )),
            0x810..0x814 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_global_intr_r()
                    .reg
                    .get(),
            )),
            0x814..0x818 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_internal_intr_r()
                    .reg
                    .get(),
            )),
            0x818..0x81c => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_internal_intr_r()
                    .reg
                    .get(),
            )),
            0x81c..0x820 => Ok(emulator_types::RvData::from(
                self.periph.read_intr_block_rf_error_intr_trig_r().reg.get(),
            )),
            0x820..0x824 => Ok(emulator_types::RvData::from(
                self.periph.read_intr_block_rf_notif_intr_trig_r().reg.get(),
            )),
            0x900..0x904 => Ok(self.periph.read_intr_block_rf_error_internal_intr_count_r()),
            0x904..0x908 => Ok(self.periph.read_intr_block_rf_error_inv_dev_intr_count_r()),
            0x908..0x90c => Ok(self.periph.read_intr_block_rf_error_cmd_fail_intr_count_r()),
            0x90c..0x910 => Ok(self.periph.read_intr_block_rf_error_bad_fuse_intr_count_r()),
            0x910..0x914 => Ok(self
                .periph
                .read_intr_block_rf_error_iccm_blocked_intr_count_r()),
            0x914..0x918 => Ok(self
                .periph
                .read_intr_block_rf_error_mbox_ecc_unc_intr_count_r()),
            0x918..0x91c => Ok(self
                .periph
                .read_intr_block_rf_error_wdt_timer1_timeout_intr_count_r()),
            0x91c..0x920 => Ok(self
                .periph
                .read_intr_block_rf_error_wdt_timer2_timeout_intr_count_r()),
            0x980..0x984 => Ok(self
                .periph
                .read_intr_block_rf_notif_cmd_avail_intr_count_r()),
            0x984..0x988 => Ok(self
                .periph
                .read_intr_block_rf_notif_mbox_ecc_cor_intr_count_r()),
            0x988..0x98c => Ok(self
                .periph
                .read_intr_block_rf_notif_debug_locked_intr_count_r()),
            0x98c..0x990 => Ok(self
                .periph
                .read_intr_block_rf_notif_scan_mode_intr_count_r()),
            0x990..0x994 => Ok(self
                .periph
                .read_intr_block_rf_notif_soc_req_lock_intr_count_r()),
            0x994..0x998 => Ok(self
                .periph
                .read_intr_block_rf_notif_gen_in_toggle_intr_count_r()),
            0xa00..0xa04 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_internal_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa04..0xa08 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_inv_dev_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa08..0xa0c => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_cmd_fail_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa0c..0xa10 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_bad_fuse_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa10..0xa14 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_iccm_blocked_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa14..0xa18 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_mbox_ecc_unc_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa18..0xa1c => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_wdt_timer1_timeout_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa1c..0xa20 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_error_wdt_timer2_timeout_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa20..0xa24 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_cmd_avail_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa24..0xa28 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_mbox_ecc_cor_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa28..0xa2c => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_debug_locked_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa2c..0xa30 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_scan_mode_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa30..0xa34 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_soc_req_lock_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            0xa34..0xa38 => Ok(emulator_types::RvData::from(
                self.periph
                    .read_intr_block_rf_notif_gen_in_toggle_intr_count_incr_r()
                    .reg
                    .get(),
            )),
            _ => Err(emulator_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
        val: emulator_types::RvData,
    ) -> Result<(), emulator_bus::BusError> {
        if addr & 0x3 != 0 || size != emulator_types::RvSize::Word {
            return Err(emulator_bus::BusError::StoreAddrMisaligned);
        }
        match addr {
            0..4 => {
                self.periph
                    .write_cptra_hw_error_fatal(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            4..8 => {
                self.periph
                    .write_cptra_hw_error_non_fatal(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            8..0xc => {
                self.periph.write_cptra_fw_error_fatal(val);
                Ok(())
            }
            0xc..0x10 => {
                self.periph.write_cptra_fw_error_non_fatal(val);
                Ok(())
            }
            0x10..0x14 => {
                self.periph.write_cptra_hw_error_enc(val);
                Ok(())
            }
            0x14..0x18 => {
                self.periph.write_cptra_fw_error_enc(val);
                Ok(())
            }
            0x18..0x38 => {
                self.periph.write_cptra_fw_extended_error_info(val);
                Ok(())
            }
            0x38..0x3c => {
                self.periph.write_cptra_boot_status(val);
                Ok(())
            }
            0x3c..0x40 => {
                self.periph
                    .write_cptra_flow_status(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x48..0x5c => {
                self.periph.write_cptra_mbox_valid_axi_user(val);
                Ok(())
            }
            0x5c..0x70 => {
                self.periph
                    .write_cptra_mbox_axi_user_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x70..0x74 => {
                self.periph.write_cptra_trng_valid_axi_user(val);
                Ok(())
            }
            0x74..0x78 => {
                self.periph
                    .write_cptra_trng_axi_user_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x78..0xa8 => {
                self.periph.write_cptra_trng_data(val);
                Ok(())
            }
            0xa8..0xac => {
                self.periph
                    .write_cptra_trng_ctrl(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xac..0xb0 => {
                self.periph
                    .write_cptra_trng_status(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xb0..0xb4 => {
                self.periph
                    .write_cptra_fuse_wr_done(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xb4..0xb8 => {
                self.periph.write_cptra_timer_config(val);
                Ok(())
            }
            0xb8..0xbc => {
                self.periph
                    .write_cptra_bootfsm_go(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xbc..0xc0 => {
                self.periph.write_cptra_dbg_manuf_service_reg(val);
                Ok(())
            }
            0xc0..0xc4 => {
                self.periph
                    .write_cptra_clk_gating_en(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xcc..0xd4 => {
                self.periph.write_cptra_generic_output_wires(val);
                Ok(())
            }
            0xd8..0xe0 => {
                self.periph.write_cptra_fw_rev_id(val);
                Ok(())
            }
            0xe4..0xe8 => {
                self.periph
                    .write_cptra_wdt_timer1_en(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xe8..0xec => {
                self.periph
                    .write_cptra_wdt_timer1_ctrl(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xec..0xf4 => {
                self.periph.write_cptra_wdt_timer1_timeout_period(val);
                Ok(())
            }
            0xf4..0xf8 => {
                self.periph
                    .write_cptra_wdt_timer2_en(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xf8..0xfc => {
                self.periph
                    .write_cptra_wdt_timer2_ctrl(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xfc..0x104 => {
                self.periph.write_cptra_wdt_timer2_timeout_period(val);
                Ok(())
            }
            0x104..0x108 => {
                self.periph
                    .write_cptra_wdt_status(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x108..0x10c => {
                self.periph.write_cptra_fuse_valid_axi_user(val);
                Ok(())
            }
            0x10c..0x110 => {
                self.periph
                    .write_cptra_fuse_axi_user_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x110..0x118 => {
                self.periph.write_cptra_wdt_cfg(val);
                Ok(())
            }
            0x118..0x11c => {
                self.periph
                    .write_cptra_i_trng_entropy_config_0(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x11c..0x120 => {
                self.periph
                    .write_cptra_i_trng_entropy_config_1(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x120..0x128 => {
                self.periph.write_cptra_rsvd_reg(val);
                Ok(())
            }
            0x128..0x12c => {
                self.periph.write_cptra_hw_capabilities(val);
                Ok(())
            }
            0x12c..0x130 => {
                self.periph.write_cptra_fw_capabilities(val);
                Ok(())
            }
            0x130..0x134 => {
                self.periph
                    .write_cptra_cap_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x140..0x170 => {
                self.periph.write_cptra_owner_pk_hash(val);
                Ok(())
            }
            0x170..0x174 => {
                self.periph
                    .write_cptra_owner_pk_hash_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x200..0x240 => {
                self.periph.write_fuse_uds_seed(val);
                Ok(())
            }
            0x240..0x260 => {
                self.periph.write_fuse_field_entropy(val);
                Ok(())
            }
            0x260..0x290 => {
                self.periph.write_fuse_key_manifest_pk_hash(val);
                Ok(())
            }
            0x290..0x2b0 => {
                self.periph.write_fuse_key_manifest_pk_hash_mask(val);
                Ok(())
            }
            0x2b4..0x2b8 => {
                self.periph.write_fuse_fmc_key_manifest_svn(val);
                Ok(())
            }
            0x2b8..0x2c8 => {
                self.periph.write_fuse_runtime_svn(val);
                Ok(())
            }
            0x2c8..0x2cc => {
                self.periph
                    .write_fuse_anti_rollback_disable(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x2cc..0x32c => {
                self.periph.write_fuse_idevid_cert_attr(val);
                Ok(())
            }
            0x32c..0x33c => {
                self.periph.write_fuse_idevid_manuf_hsm_id(val);
                Ok(())
            }
            0x340..0x344 => {
                self.periph.write_fuse_lms_revocation(val);
                Ok(())
            }
            0x344..0x348 => {
                self.periph
                    .write_fuse_mldsa_revocation(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x348..0x34c => {
                self.periph
                    .write_fuse_soc_stepping_id(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x34c..0x35c => {
                self.periph.write_fuse_manuf_dbg_unlock_token(val);
                Ok(())
            }
            0x500..0x504 => {
                self.periph.write_ss_caliptra_base_addr_l(val);
                Ok(())
            }
            0x504..0x508 => {
                self.periph.write_ss_caliptra_base_addr_h(val);
                Ok(())
            }
            0x508..0x50c => {
                self.periph.write_ss_mci_base_addr_l(val);
                Ok(())
            }
            0x50c..0x510 => {
                self.periph.write_ss_mci_base_addr_h(val);
                Ok(())
            }
            0x510..0x514 => {
                self.periph.write_ss_recovery_ifc_base_addr_l(val);
                Ok(())
            }
            0x514..0x518 => {
                self.periph.write_ss_recovery_ifc_base_addr_h(val);
                Ok(())
            }
            0x518..0x51c => {
                self.periph.write_ss_otp_fc_base_addr_l(val);
                Ok(())
            }
            0x51c..0x520 => {
                self.periph.write_ss_otp_fc_base_addr_h(val);
                Ok(())
            }
            0x520..0x524 => {
                self.periph.write_ss_uds_seed_base_addr_l(val);
                Ok(())
            }
            0x524..0x528 => {
                self.periph.write_ss_uds_seed_base_addr_h(val);
                Ok(())
            }
            0x528..0x52c => {
                self.periph
                    .write_ss_prod_debug_unlock_auth_pk_hash_reg_bank_offset(val);
                Ok(())
            }
            0x52c..0x530 => {
                self.periph
                    .write_ss_num_of_prod_debug_unlock_auth_pk_hashes(val);
                Ok(())
            }
            0x5a0..0x5b0 => {
                self.periph.write_ss_strap_generic(val);
                Ok(())
            }
            0x5c0..0x5c4 => {
                self.periph
                    .write_ss_dbg_manuf_service_reg_req(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x5c4..0x5c8 => {
                self.periph
                    .write_ss_dbg_manuf_service_reg_rsp(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x5c8..0x5d0 => {
                self.periph.write_ss_soc_dbg_unlock_level(val);
                Ok(())
            }
            0x5d0..0x5e0 => {
                self.periph.write_ss_generic_fw_exec_ctrl(val);
                Ok(())
            }
            0x600..0x620 => {
                self.periph.write_internal_obf_key(val);
                Ok(())
            }
            0x620..0x624 => {
                self.periph
                    .write_internal_iccm_lock(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x624..0x628 => {
                self.periph
                    .write_internal_fw_update_reset(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x628..0x62c => {
                self.periph.write_internal_fw_update_reset_wait_cycles(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x62c..0x630 => {
                self.periph.write_internal_nmi_vector(val);
                Ok(())
            }
            0x630..0x634 => {
                self.periph
                    .write_internal_hw_error_fatal_mask(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x634..0x638 => {
                self.periph.write_internal_hw_error_non_fatal_mask(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x638..0x63c => {
                self.periph.write_internal_fw_error_fatal_mask(val);
                Ok(())
            }
            0x63c..0x640 => {
                self.periph.write_internal_fw_error_non_fatal_mask(val);
                Ok(())
            }
            0x640..0x644 => {
                self.periph.write_internal_rv_mtime_l(val);
                Ok(())
            }
            0x644..0x648 => {
                self.periph.write_internal_rv_mtime_h(val);
                Ok(())
            }
            0x648..0x64c => {
                self.periph.write_internal_rv_mtimecmp_l(val);
                Ok(())
            }
            0x64c..0x650 => {
                self.periph.write_internal_rv_mtimecmp_h(val);
                Ok(())
            }
            0x800..0x804 => {
                self.periph.write_intr_block_rf_global_intr_en_r(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x804..0x808 => {
                self.periph
                    .write_intr_block_rf_error_intr_en_r(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x808..0x80c => {
                self.periph
                    .write_intr_block_rf_notif_intr_en_r(emulator_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x814..0x818 => {
                self.periph.write_intr_block_rf_error_internal_intr_r(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x818..0x81c => {
                self.periph.write_intr_block_rf_notif_internal_intr_r(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x81c..0x820 => {
                self.periph.write_intr_block_rf_error_intr_trig_r(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x820..0x824 => {
                self.periph.write_intr_block_rf_notif_intr_trig_r(
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            0x900..0x904 => {
                self.periph
                    .write_intr_block_rf_error_internal_intr_count_r(val);
                Ok(())
            }
            0x904..0x908 => {
                self.periph
                    .write_intr_block_rf_error_inv_dev_intr_count_r(val);
                Ok(())
            }
            0x908..0x90c => {
                self.periph
                    .write_intr_block_rf_error_cmd_fail_intr_count_r(val);
                Ok(())
            }
            0x90c..0x910 => {
                self.periph
                    .write_intr_block_rf_error_bad_fuse_intr_count_r(val);
                Ok(())
            }
            0x910..0x914 => {
                self.periph
                    .write_intr_block_rf_error_iccm_blocked_intr_count_r(val);
                Ok(())
            }
            0x914..0x918 => {
                self.periph
                    .write_intr_block_rf_error_mbox_ecc_unc_intr_count_r(val);
                Ok(())
            }
            0x918..0x91c => {
                self.periph
                    .write_intr_block_rf_error_wdt_timer1_timeout_intr_count_r(val);
                Ok(())
            }
            0x91c..0x920 => {
                self.periph
                    .write_intr_block_rf_error_wdt_timer2_timeout_intr_count_r(val);
                Ok(())
            }
            0x980..0x984 => {
                self.periph
                    .write_intr_block_rf_notif_cmd_avail_intr_count_r(val);
                Ok(())
            }
            0x984..0x988 => {
                self.periph
                    .write_intr_block_rf_notif_mbox_ecc_cor_intr_count_r(val);
                Ok(())
            }
            0x988..0x98c => {
                self.periph
                    .write_intr_block_rf_notif_debug_locked_intr_count_r(val);
                Ok(())
            }
            0x98c..0x990 => {
                self.periph
                    .write_intr_block_rf_notif_scan_mode_intr_count_r(val);
                Ok(())
            }
            0x990..0x994 => {
                self.periph
                    .write_intr_block_rf_notif_soc_req_lock_intr_count_r(val);
                Ok(())
            }
            0x994..0x998 => {
                self.periph
                    .write_intr_block_rf_notif_gen_in_toggle_intr_count_r(val);
                Ok(())
            }
            _ => Err(emulator_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
