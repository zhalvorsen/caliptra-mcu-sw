// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 39dd3917923c26515ca02c547807706f797428df
//
pub const I3C_CSR_ADDR: u32 = 0x2000_4000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub AltQueueSize [
                /// 1 indicates that IBI queue size is equal to 8*IBI_STATUS_SIZE
                ExtIbiQueueEn OFFSET(28) NUMBITS(1) [],
                /// If set, response and command queues are not equal lengths, then
                /// ALT_RESP_QUEUE_SIZE contains response queue size
                AltRespQueueEn OFFSET(24) NUMBITS(1) [],
                /// Valid only if ALT_RESP_QUEUE_EN is set. Contains response queue size
                AltRespQueueSize OFFSET(0) NUMBITS(8) [],
            ],
            pub Control [
                /// Number of times the Target Device will try to request an IBI before giving up.
                ///
                /// Values:
                ///
                /// 0x0 - Device will never retry.
                ///
                /// 0x1-0x6 - Device will retry this many times.
                ///
                /// 0x7 - Device will retry indefinitely until the Active Controller sets
                /// DISINT bit in the DISEC command.
                IbiRetryNum OFFSET(13) NUMBITS(3) [],
                /// Enable the IBI queue servicing.
                ///
                /// Values:
                ///
                /// 0x0 - Device will not service the IBI queue.
                ///
                /// 0x1 - Device will send IBI requests onto the bus, if possible.
                IbiEn OFFSET(12) NUMBITS(1) [],
                /// Enable Controller Role Request.
                ///
                /// Values:
                ///
                /// 0x0 - Device is allowed to perform Controller Role Request.
                ///
                /// 0x1 - Device is not allowed to perform Controller Role Request.
                CrrEn OFFSET(11) NUMBITS(1) [],
                /// Enable Hot-Join capability.
                ///
                /// Values:
                ///
                /// 0x0 - Device is allowed to attempt Hot-Join.
                ///
                /// 0x1 - Device is not allowed to attempt Hot-Join.
                HjEn OFFSET(10) NUMBITS(1) [],
            ],
            pub ControllerConfig [
                OperationMode OFFSET(4) NUMBITS(2) [],
            ],
            pub ControllerDeviceAddr [
                /// Dynamic Address is Valid:
                ///
                /// 0 - dynamic address is invalid
                ///
                /// 1 - dynamic address is valid
                DynamicAddrValid OFFSET(31) NUMBITS(1) [],
                /// Device Dynamic Address
                DynamicAddr OFFSET(16) NUMBITS(7) [],
            ],
            pub DataBufferThldCtrl [
                /// Postpone read command until RX queue has 2^(N+1) free entries
                RxStartThld OFFSET(24) NUMBITS(3) [],
                /// Postpone write command until TX queue has 2^(N+1) entries
                TxStartThld OFFSET(16) NUMBITS(3) [],
                /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
                RxBufThld OFFSET(8) NUMBITS(3) [],
                /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
                TxBufThld OFFSET(0) NUMBITS(3) [],
            ],
            pub DatSectionOffset [
                /// Individual DAT entry size.
                /// 0 - 2 DWRODs,
                /// 1:15 - reserved.
                EntrySize OFFSET(28) NUMBITS(4) [],
                /// Max number of DAT entries.
                TableSize OFFSET(12) NUMBITS(7) [],
                /// DAT entry offset in respect to BASE address.
                TableOffset OFFSET(0) NUMBITS(12) [],
            ],
            pub DctSectionOffset [
                /// Individual DCT entry size.
                ///
                /// 0 - 4 DWORDs,
                ///
                /// 1:15 - Reserved.
                EntrySize OFFSET(28) NUMBITS(4) [],
                /// Index to DCT used during ENTDAA.
                TableIndex OFFSET(19) NUMBITS(5) [],
                /// Max number of DCT entries.
                TableSize OFFSET(12) NUMBITS(7) [],
                /// DCT entry offset in respect to BASE address.
                TableOffset OFFSET(0) NUMBITS(12) [],
            ],
            pub DeviceId0 [
                /// Based on table 8 from [DMTF PLDM FM]:
                ///
                /// * 0x00: PCI Vendor
                ///
                /// * 0x1: IANA
                ///
                /// * 0x2: UUID
                ///
                /// * 0x3: PnP Vendor
                ///
                /// * 0x4: ACPI Vendor
                ///
                /// * 0x5: IANA Enterprise Type
                ///
                /// * 0x6-0xFE: Reserved
                ///
                /// * 0xFF: NVMe-MI
                DescType OFFSET(0) NUMBITS(8) [],
                /// 0x0-0xFF: Total length of Vendor Specific String, 0 indicates not supported
                VendorSpecificStrLength OFFSET(8) NUMBITS(8) [],
                Data OFFSET(16) NUMBITS(16) [],
            ],
            pub DeviceReset [
                /// * 0x0: No reset
                ///
                /// * 0x1: Reset Device (PCIe Fundamental Reset or equivalent. This is likely bus disruptive)
                ///
                /// * 0x2: Reset Management. This reset will reset the management subsystem. If supported, this reset MUST not be bus disruptive (cause re-enumeration)
                ///
                /// * 0x3-FF: Reserved
                ResetCtrl OFFSET(0) NUMBITS(8) [],
                /// * 0x0: No forced recovery
                ///
                /// * 0x01-0xD: Reserved
                ///
                /// * 0xE: Enter flashless boot mode on next platform reset
                ///
                /// * 0xF: Enter recovery mode on next platform reset
                ///
                /// * 0x10-FF: Reserved
                ForcedRecovery OFFSET(8) NUMBITS(8) [],
                /// * 0x0: Disable Interface mastering
                ///
                /// * 0x1: Enable Interface mastering
                IfCtrl OFFSET(16) NUMBITS(8) [],
            ],
            pub DeviceStatus0 [
                /// * 0x0: Status Pending (Recover Reason Code not populated)
                ///
                /// * 0x1: Device healthy (Recover Reason Code not populated)
                ///
                /// * 0x2: Device Error (“soft” error or other error state) - (Recover Reason Code not populated)
                ///
                /// * 0x3: Recovery mode - ready to accept recovery image - (Recover Reason Code populated)
                ///
                /// * 0x4: Recovery Pending (waiting for activation) - (Recover Reason Code populated)
                ///
                /// * 0x5: Running Recovery Image ( Recover Reason Code not populated)
                ///
                /// * 0x6-0xD: Reserved
                ///
                /// * 0xE: Boot Failure (Recover Reason Code populated)
                ///
                /// * 0xF: Fatal Error (Recover Reason Code not populated)
                ///
                /// * 0x10-FF:Reserved
                DevStatus OFFSET(0) NUMBITS(8) [],
                /// * 0x0: No Protocol Error
                ///
                /// * 0x1: Unsupported/Write Command - command is not support or a write to a RO command
                ///
                /// * 0x2: Unsupported Parameter
                ///
                /// * 0x3: Length write error (length of write command is incorrect)
                ///
                /// * 0x4: CRC Error (if supported)
                ///
                /// * 0x5-0xFE: Reserved
                ///
                /// * 0xFF: General Protocol Error - catch all unclassified errors
                ProtError OFFSET(8) NUMBITS(8) [],
                /// * 0x0: No Boot Failure detected (BFNF)
                ///
                /// * 0x1: Generic hardware error (BFGHWE)
                ///
                /// * 0x2: Generic hardware soft error (BFGSE) - soft error may be recoverable
                ///
                /// * 0x3: Self-test failure (BFSTF) (e.g., RSA self test failure, FIPs self test failure,, etc.)
                ///
                /// * 0x4: Corrupted/missing critical data (BFCD)
                ///
                /// * 0x5: Missing/corrupt key manifest (BFKMMC)
                ///
                /// * 0x6: Authentication Failure on key manifest (BFKMAF)
                ///
                /// * 0x7: Anti-rollback failure on key manifest (BFKIAR)
                ///
                /// * 0x8: Missing/corrupt boot loader (first mutable code) firmware image (BFFIMC)
                ///
                /// * 0x9: Authentication failure on boot loader ( 1st mutable code) firmware image (BFFIAF)
                ///
                /// * 0xA: Anti-rollback failure boot loader (1st mutable code) firmware image (BFFIAR)
                ///
                /// * 0xB: Missing/corrupt main/management firmware image (BFMFMC)
                ///
                /// * 0xC: Authentication Failure main/management firmware image (BFMFAF)
                ///
                /// * 0xD: Anti-rollback Failure main/management firmware image (BFMFAR)
                ///
                /// * 0xE: Missing/corrupt recovery firmware (BFRFMC)
                ///
                /// * 0xF: Authentication Failure recovery firmware (BFRFAF)
                ///
                /// * 0x10: Anti-rollback Failure on recovery firmware (BFRFAR)
                ///
                /// * 0x11: Forced Recovery (FR)
                ///
                /// * 0x12: Flashless/Streaming Boot (FSB)
                ///
                /// * 0x13-0x7F: Reserved
                ///
                /// * 0x80-0xFF: Vendor Unique Boot Failure Codes
                RecReasonCode OFFSET(16) NUMBITS(16) [],
            ],
            pub DeviceStatus1 [
                /// 0-4095: Incrementing number (counter wraps)
                Heartbeat OFFSET(0) NUMBITS(16) [],
                /// 0-248: Length in bytes of just VENDOR_STATUS. Zero indicates no vendor status and zero additional bytes.
                VendorStatusLength OFFSET(16) NUMBITS(9) [],
                VendorStatus OFFSET(25) NUMBITS(7) [],
            ],
            pub DevCtxBaseHi [
                BaseHi OFFSET(0) NUMBITS(1) [],
            ],
            pub DevCtxBaseLo [
                BaseLo OFFSET(0) NUMBITS(1) [],
            ],
            pub DevCtxSg [
                /// Buffer vs list pointer in device context:
                ///
                /// 0 - continuous physical memory region,
                ///
                /// 1 - pointer to SG descriptor list.
                Blp OFFSET(31) NUMBITS(1) [],
                /// Number of SG entries.
                ListSize OFFSET(0) NUMBITS(16) [],
            ],
            pub ExtcapHeader [
                /// Capability Structure Length in DWORDs
                CapLength OFFSET(8) NUMBITS(16) [],
                /// Extended Capability ID
                CapId OFFSET(0) NUMBITS(8) [],
            ],
            pub ExtCapsSectionOffset [
                /// Extended Capabilities section offset. Invalid if 0.
                SectionOffset OFFSET(0) NUMBITS(16) [],
            ],
            pub HcCapabilities [
                /// Device context memory:
                ///
                /// 0 - must be physically continuous
                ///
                /// 1 - controller supports scatter-gather
                SgCapabilityDcEn OFFSET(30) NUMBITS(1) [],
                /// DMA only: IBI status and IBI Data rings memory:
                ///
                /// 0 - must be physically continuous
                ///
                /// 1 - controller supports scatter-gather
                SgCapabilityIbiEn OFFSET(29) NUMBITS(1) [],
                /// DMA only: Command and Response rings memory:
                ///
                /// 0 - must be physically continuous
                ///
                /// 1 - controller supports scatter-gather
                SgCapabilityCrEn OFFSET(28) NUMBITS(1) [],
                /// Size and structure of the Command Descriptor:
                ///
                /// 2'b0: 2 DWORDs,
                ///
                /// all other reserved.
                CmdSize OFFSET(20) NUMBITS(2) [],
                /// Controller command scheduling:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                ScheduledCommandsEn OFFSET(13) NUMBITS(1) [],
                /// Controller IBI credit count:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                IbiCreditCountEn OFFSET(12) NUMBITS(1) [],
                /// Controller IBI data abort:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                IbiDataAbortEn OFFSET(11) NUMBITS(1) [],
                /// CCC with defining byte:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                CmdCccDefbyte OFFSET(10) NUMBITS(1) [],
                /// HDR-Ternary transfers:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                HdrTsEn OFFSET(7) NUMBITS(1) [],
                /// HDR-DDR transfers:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                HdrDdrEn OFFSET(6) NUMBITS(1) [],
                /// Switching from active to standby mode:
                ///
                /// 0 - not supported, this controller is always active on I3C
                ///
                /// 1- supported, this controller can hand off I3C to secondary controller
                StandbyCrCap OFFSET(5) NUMBITS(1) [],
                /// Automatic read command on IBI:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                AutoCommand OFFSET(3) NUMBITS(1) [],
                /// Controller combined command:
                ///
                /// 0 - not supported
                ///
                /// 1 - supported
                ComboCommand OFFSET(2) NUMBITS(1) [],
            ],
            pub HcControl [
                /// Host Controller Bus Enable
                BusEnable OFFSET(31) NUMBITS(1) [],
                /// Host Controller Resume:
                ///
                /// 0 - Controller is running
                ///
                /// 1 - Controller is suspended
                ///
                /// Write 1 to resume Controller operations.
                Resume OFFSET(30) NUMBITS(1) [],
                /// Host Controller Abort when set to 1
                Abort OFFSET(29) NUMBITS(1) [],
                /// Halt on Command Sequence Timeout when set to 1
                HaltOnCmdSeqTimeout OFFSET(12) NUMBITS(1) [],
                /// Hot-Join ACK/NACK Control:
                ///
                /// 0 - ACK Hot-Join request
                ///
                /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
                HotJoinCtrl OFFSET(8) NUMBITS(1) [],
                /// I2C Device Present on Bus:
                ///
                /// 0 - pure I3C bus
                ///
                /// 1 - legacy I2C devices on the bus
                I2cDevPresent OFFSET(7) NUMBITS(1) [],
                /// DMA/PIO Mode Selector:
                ///
                /// 0 - DMA
                ///
                /// 1 - PIO
                ModeSelector OFFSET(6) NUMBITS(1) [],
                /// Data Byte Ordering Mode:
                ///
                /// 0 - Little Endian
                ///
                /// 1 - Big Endian
                DataByteOrderMode OFFSET(4) NUMBITS(1) [],
                /// Auto-Command Data Report:
                ///
                /// 0 - coalesced reporting
                ///
                /// 1 - separated reporting
                AutocmdDataRpt OFFSET(3) NUMBITS(1) [],
                /// Include I3C Broadcast Address:
                ///
                /// 0 - skips I3C Broadcast Address for private transfers
                ///
                /// 1 - includes I3C Broadcast Address for private transfers
                IbaInclude OFFSET(0) NUMBITS(1) [],
            ],
            pub HwStatus [
                /// Device temperature is critical (may need reset to clear)
                TempCritical OFFSET(0) NUMBITS(1) [],
                /// Hardware Soft Error (may need reset to clear)
                SoftErr OFFSET(1) NUMBITS(1) [],
                FatalErr OFFSET(2) NUMBITS(1) [],
                Reserved73 OFFSET(3) NUMBITS(5) [],
                VendorHwStatus OFFSET(8) NUMBITS(8) [],
                /// Current temperatureof device in degrees Celsius: Compatible with NVMe-MI command code 0 offset 3.
                ///
                /// * 0x00-0x7e: 0 to 126 C
                ///
                /// * 0x7f: 127 C or higher
                ///
                /// * 0x80: no temperature data, or data is older than 5 seconds
                ///
                /// * 0x81: temperature sensor failure
                ///
                /// * 0x82-0x83: reserved
                ///
                /// * 0xc4: -60 C or lower
                ///
                /// * 0xc5-0xff: -59 to -1 C (in two's complement)
                Ctemp OFFSET(16) NUMBITS(8) [],
                /// 0-251: Length in bytes of Vendor Specific Hardware Status.
                VendorHwStatusLen OFFSET(24) NUMBITS(8) [],
            ],
            pub IbiDataAbortCtrl [
                /// Enable/disable IBI monitoring logic.
                IbiDataAbortMon OFFSET(31) NUMBITS(1) [],
                /// Define which IBI should be aborted:
                ///
                /// 3'b000 - Regular IBI,
                ///
                /// 3'b100 - Autocmd IBI,
                ///
                /// other values - not supported.
                MatchStatusType OFFSET(18) NUMBITS(3) [],
                /// Number of data chunks to be allowed before forced termination:
                ///
                /// 0 - immediate,
                ///
                /// 1:3 - delay by 1-3 data chunks.
                AfterNChunks OFFSET(16) NUMBITS(2) [],
                /// IBI target address:
                ///
                /// [15:9] - device address,
                ///
                /// [8] - must always be set to 1'b1
                MatchIbiId OFFSET(8) NUMBITS(8) [],
            ],
            pub IbiNotifyCtrl [
                /// Notify about rejected IBI:
                ///
                /// 0 - do not enqueue rejected IBI,
                ///
                /// 1 = enqueue rejected IBI on IBI queue/ring.
                NotifyIbiRejected OFFSET(3) NUMBITS(1) [],
                /// Notify about rejected controller role request:
                ///
                /// 0 - do not enqueue rejected CRR,
                ///
                /// 1 = enqueue rejected CRR on IBI queue/ring.
                NotifyCrrRejected OFFSET(1) NUMBITS(1) [],
                /// Notify about rejected hot-join:
                ///
                /// 0 - do not enqueue rejected HJ,
                ///
                /// 1 = enqueue rejected HJ on IBI queue/ring.
                NotifyHjRejected OFFSET(0) NUMBITS(1) [],
            ],
            pub IbiTtiQueueSize [
                /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
                IbiTtiQueueSize OFFSET(0) NUMBITS(8) [],
            ],
            pub IndirectFifoCtrl0 [
                /// This register selects a region within the device. Read/write access is through address
                /// spaces. Each space represents a FIFO.
                /// Component Memory Space (CMS):
                ///
                /// * 0-255: Address region within a device.
                Cms OFFSET(0) NUMBITS(8) [],
                /// Reset (Write 1 Clear):
                ///
                /// * 0x0: idle
                ///
                /// * 0x1: reset Write Index and Read Index to initial value.
                ///
                /// * 0x2 to 0xFF: reserved
                Reset OFFSET(8) NUMBITS(8) [],
            ],
            pub IndirectFifoStatus0 [
                /// If set, FIFO is empty
                Empty OFFSET(0) NUMBITS(1) [],
                /// If set, FIFO is full
                Full OFFSET(1) NUMBITS(1) [],
                /// Memory Region Type:
                ///
                /// * 0b000: Code space for recovery. (write only)
                ///
                /// * 0b001: Log uses the defined debug format (read only)
                ///
                /// * 0b100: Vendor Defined Region (write only)
                ///
                /// * 0b101: Vendor Defined Region (read only)
                ///
                /// * 0b111: Unsupported Region (address space out of range)
                RegionType OFFSET(8) NUMBITS(3) [],
            ],
            pub InterruptEnable [
                /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT`
                TransferErrStatEn OFFSET(31) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_COMPLETE_EN`
                TxDescCompleteEn OFFSET(26) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT`
                TransferAbortStatEn OFFSET(25) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `IBI_DONE`
                IbiDoneEn OFFSET(13) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
                IbiThldStatEn OFFSET(12) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
                RxDescThldStatEn OFFSET(11) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
                TxDescThldStatEn OFFSET(10) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
                RxDataThldStatEn OFFSET(9) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
                TxDataThldStatEn OFFSET(8) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_EN`
                TxDescTimeoutEn OFFSET(3) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_EN`
                RxDescTimeoutEn OFFSET(2) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_STAT_EN`
                TxDescStatEn OFFSET(1) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `RX_DESC_STAT_EN`
                RxDescStatEn OFFSET(0) NUMBITS(1) [],
            ],
            pub InterruptForce [
                /// Enables the corresponding interrupt bit `TRANSFER_ERR_STAT_FORCE`
                TransferErrStatForce OFFSET(31) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_COMPLETE_FORCE`
                TxDescCompleteForce OFFSET(26) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TRANSFER_ABORT_STAT_FORCE`
                TransferAbortStatForce OFFSET(25) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `IBI_DONE_FORCE`
                IbiDoneForce OFFSET(13) NUMBITS(1) [],
                /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
                IbiThldForce OFFSET(12) NUMBITS(1) [],
                /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
                RxDescThldForce OFFSET(11) NUMBITS(1) [],
                /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
                TxDescThldForce OFFSET(10) NUMBITS(1) [],
                /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
                RxDataThldForce OFFSET(9) NUMBITS(1) [],
                /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
                TxDataThldForce OFFSET(8) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_TIMEOUT_FORCE`
                TxDescTimeoutForce OFFSET(3) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `RX_DESC_TIMEOUT_FORCE`
                RxDescTimeoutForce OFFSET(2) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `TX_DESC_STAT_FORCE`
                TxDescStatForce OFFSET(1) NUMBITS(1) [],
                /// Enables the corresponding interrupt bit `RX_DESC_STAT_FORCE`
                RxDescStatForce OFFSET(0) NUMBITS(1) [],
            ],
            pub InterruptStatus [
                /// Bus error occurred
                TransferErrStat OFFSET(31) NUMBITS(1) [],
                /// Read Transaction on the I3C Bus completede
                TxDescComplete OFFSET(26) NUMBITS(1) [],
                /// Bus aborted transaction
                TransferAbortStat OFFSET(25) NUMBITS(1) [],
                /// Contains the interrupt number of any pending interrupt, or 0 if no interrupts are pending. This encoding allows for up to 15 numbered interrupts. If more than one interrupt is set, then the highest priority interrupt shall be returned.
                PendingInterrupt OFFSET(15) NUMBITS(4) [],
                /// IBI is done, check LAST_IBI_STATUS for result.
                IbiDone OFFSET(13) NUMBITS(1) [],
                /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
                IbiThldStat OFFSET(12) NUMBITS(1) [],
                /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
                RxDescThldStat OFFSET(11) NUMBITS(1) [],
                /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
                TxDescThldStat OFFSET(10) NUMBITS(1) [],
                /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
                RxDataThldStat OFFSET(9) NUMBITS(1) [],
                /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
                TxDataThldStat OFFSET(8) NUMBITS(1) [],
                /// Pending Read was NACK’ed, because the `TX_DESC_STAT` event was not handled in time
                TxDescTimeout OFFSET(3) NUMBITS(1) [],
                /// Pending Write was NACK’ed, because the `RX_DESC_STAT` event was not handled in time
                RxDescTimeout OFFSET(2) NUMBITS(1) [],
                /// There is a pending Read Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
                TxDescStat OFFSET(1) NUMBITS(1) [],
                /// There is a pending Write Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
                RxDescStat OFFSET(0) NUMBITS(1) [],
            ],
            pub IntrForce [
                /// Force SCHED_CMD_MISSED_TICK_STAT interrupt.
                SchedCmdMissedTickForce OFFSET(14) NUMBITS(1) [],
                /// Force HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
                HcErrCmdSeqTimeoutForce OFFSET(13) NUMBITS(1) [],
                /// Force HC_WARN_CMD_SEQ_STALL_STAT interrupt.
                HcWarnCmdSeqStallForce OFFSET(12) NUMBITS(1) [],
                /// Force HC_SEQ_CANCEL_STAT interrupt.
                HcSeqCancelForce OFFSET(11) NUMBITS(1) [],
                /// Force HC_INTERNAL_ERR_STAT interrupt.
                HcInternalErrForce OFFSET(10) NUMBITS(1) [],
            ],
            pub IntrSignalEnable [
                /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
                SchedCmdMissedTickSignalEn OFFSET(14) NUMBITS(1) [],
                /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
                HcErrCmdSeqTimeoutSignalEn OFFSET(13) NUMBITS(1) [],
                /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
                HcWarnCmdSeqStallSignalEn OFFSET(12) NUMBITS(1) [],
                /// Enable HC_SEQ_CANCEL_STAT interrupt.
                HcSeqCancelSignalEn OFFSET(11) NUMBITS(1) [],
                /// Enable HC_INTERNAL_ERR_STAT interrupt.
                HcInternalErrSignalEn OFFSET(10) NUMBITS(1) [],
            ],
            pub IntrStatus [
                /// Scheduled commands could be executed due to controller being busy.
                SchedCmdMissedTickStat OFFSET(14) NUMBITS(1) [],
                /// Command timeout after prolonged stall.
                HcErrCmdSeqTimeoutStat OFFSET(13) NUMBITS(1) [],
                /// Clock stalled due to lack of commands.
                HcWarnCmdSeqStallStat OFFSET(12) NUMBITS(1) [],
                /// Controller had to cancel command sequence.
                HcSeqCancelStat OFFSET(11) NUMBITS(1) [],
                /// Controller internal unrecoverable error.
                HcInternalErrStat OFFSET(10) NUMBITS(1) [],
            ],
            pub IntrStatusEnable [
                /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
                SchedCmdMissedTickStatEn OFFSET(14) NUMBITS(1) [],
                /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
                HcErrCmdSeqTimeoutStatEn OFFSET(13) NUMBITS(1) [],
                /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
                HcWarnCmdSeqStallStatEn OFFSET(12) NUMBITS(1) [],
                /// Enable HC_SEQ_CANCEL_STAT monitoring.
                HcSeqCancelStatEn OFFSET(11) NUMBITS(1) [],
                /// Enable HC_INTERNAL_ERR_STAT monitoring.
                HcInternalErrStatEn OFFSET(10) NUMBITS(1) [],
            ],
            pub IntCtrlCmdsEn [
                /// Bitmask of supported MIPI commands.
                MipiCmdsSupported OFFSET(1) NUMBITS(15) [],
                /// Internal Control Commands:
                ///
                /// 1 - some or all internals commands sub-commands are supported,
                ///
                /// 0 - illegal.
                IccSupport OFFSET(0) NUMBITS(1) [],
            ],
            pub PioControl [
                /// Stop current command descriptor execution forcefully and hold remaining commands.
                /// 1 - Request PIO Abort,
                /// 0 - Resume PIO execution
                Abort OFFSET(2) NUMBITS(1) [],
                /// Run/Stop execution of enqueued commands.
                /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
                /// 1 - PIO Queue start request,
                /// 0 - PIO Queue stop request.
                Rs OFFSET(1) NUMBITS(1) [],
                /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
                /// 1 - PIO queue enable request,
                /// 0 - PIO queue disable request
                Enable OFFSET(0) NUMBITS(1) [],
            ],
            pub PioIntrForce [
                /// Force transfer error
                TransferErrForce OFFSET(9) NUMBITS(1) [],
                /// Force transfer aborted
                TransferAbortForce OFFSET(5) NUMBITS(1) [],
                /// Force response queue interrupt
                RespReadyForce OFFSET(4) NUMBITS(1) [],
                /// Force command queue interrupt
                CmdQueueReadyForce OFFSET(3) NUMBITS(1) [],
                /// Force IBI queue interrupt
                IbiThldForce OFFSET(2) NUMBITS(1) [],
                /// Force RX queue interrupt
                RxThldForce OFFSET(1) NUMBITS(1) [],
                /// Force TX queue interrupt
                TxThldForce OFFSET(0) NUMBITS(1) [],
            ],
            pub PioIntrSignalEnable [
                /// Enable transfer error interrupt
                TransferErrSignalEn OFFSET(9) NUMBITS(1) [],
                /// Enable transfer abort interrupt
                TransferAbortSignalEn OFFSET(5) NUMBITS(1) [],
                /// Enable response ready interrupt
                RespReadySignalEn OFFSET(4) NUMBITS(1) [],
                /// Enable command queue interrupt
                CmdQueueReadySignalEn OFFSET(3) NUMBITS(1) [],
                /// Enable IBI queue interrupt
                IbiStatusThldSignalEn OFFSET(2) NUMBITS(1) [],
                /// Enable RX queue interrupt
                RxThldSignalEn OFFSET(1) NUMBITS(1) [],
                /// Enable TX queue interrupt
                TxThldSignalEn OFFSET(0) NUMBITS(1) [],
            ],
            pub PioIntrStatus [
                /// Transfer error
                TransferErrStat OFFSET(9) NUMBITS(1) [],
                /// Transfer aborted
                TransferAbortStat OFFSET(5) NUMBITS(1) [],
                /// Response queue fulfils RESP_BUF_THLD
                RespReadyStat OFFSET(4) NUMBITS(1) [],
                /// Command queue fulfils CMD_EMPTY_BUF_THLD
                CmdQueueReadyStat OFFSET(3) NUMBITS(1) [],
                /// IBI queue fulfils IBI_STATUS_THLD
                IbiStatusThldStat OFFSET(2) NUMBITS(1) [],
                /// RX queue fulfils RX_BUF_THLD
                RxThldStat OFFSET(1) NUMBITS(1) [],
                /// TX queue fulfils TX_BUF_THLD
                TxThldStat OFFSET(0) NUMBITS(1) [],
            ],
            pub PioIntrStatusEnable [
                /// Enable transfer error monitoring
                TransferErrStatEn OFFSET(9) NUMBITS(1) [],
                /// Enable transfer abort monitoring
                TransferAbortStatEn OFFSET(5) NUMBITS(1) [],
                /// Enable response queue monitoring
                RespReadyStatEn OFFSET(4) NUMBITS(1) [],
                /// Enable command queue monitoring
                CmdQueueReadyStatEn OFFSET(3) NUMBITS(1) [],
                /// Enable IBI queue monitoring
                IbiStatusThldStatEn OFFSET(2) NUMBITS(1) [],
                /// Enable RX queue monitoring
                RxThldStatEn OFFSET(1) NUMBITS(1) [],
                /// Enable TX queue monitoring
                TxThldStatEn OFFSET(0) NUMBITS(1) [],
            ],
            pub PioSectionOffset [
                /// PIO section offset. Invalid if 0.
                SectionOffset OFFSET(0) NUMBITS(16) [],
            ],
            pub PresentState [
                /// Controller I3C state:
                ///
                /// 0 - not bus owner
                ///
                /// 1 - bus owner
                AcCurrentOwn OFFSET(2) NUMBITS(1) [],
            ],
            pub ProtCap2 [
                /// * Byte 0: Major version number = 0x1
                ///
                /// * Byte 1: Minor version number = 0x1
                RecProtVersion OFFSET(0) NUMBITS(16) [],
                /// Agent capabilities:
                ///
                /// * bit 0: Identification (DEVICE_ID structure)
                ///
                /// * bit 1: Forced Recovery (From RESET)
                ///
                /// * bit 2: Mgmt reset (From RESET)
                ///
                /// * bit 3: Device Reset (From RESET)
                ///
                /// * bit 4: Device status (DEVICE_STATUS)
                ///
                /// * bit 5: Recovery memory access (INDIRECT_CTRL)
                ///
                /// * bit 6: Local C-image support
                ///
                /// * bit 7: Push C-image support
                ///
                /// * bit 8: Interface isolation
                ///
                /// * bit 9: Hardware status
                ///
                /// * bit 10: Vendor command
                ///
                /// * bit 11: Flashless boot (From RESET)
                ///
                /// * bit 12: FIFO CMS support (INDIRECT_FIFO_CTRL)
                ///
                /// * bits 13-15: Reserved
                AgentCaps OFFSET(16) NUMBITS(16) [],
            ],
            pub ProtCap3 [
                /// 0-255: The total number of component memory space (CMS) regions a device supports. This number includes any logging, code and vendor defined regions
                NumOfCmsRegions OFFSET(0) NUMBITS(8) [],
                /// 0-255: Maximum response time in 2^x microseconds(us).
                MaxRespTime OFFSET(8) NUMBITS(8) [],
                /// 0-255: Heartbeat period, 2^x microseconds (us), 0 indicates not supported
                HeartbeatPeriod OFFSET(16) NUMBITS(8) [],
            ],
            pub QueueSize [
                /// TX queue size is equal to 2^(N+1), where N is this field value
                TxDataBufferSize OFFSET(24) NUMBITS(8) [],
                /// RX queue size is equal to 2^(N+1), where N is this field value
                RxDataBufferSize OFFSET(16) NUMBITS(8) [],
                /// IBI Queue size is equal to N
                IbiStatusSize OFFSET(8) NUMBITS(8) [],
                /// Command/Response queue size is equal to N
                CrQueueSize OFFSET(0) NUMBITS(8) [],
            ],
            pub QueueThldCtrl [
                /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
                IbiStatusThld OFFSET(24) NUMBITS(8) [],
                /// IBI Queue data segment size. Valida values are 1:63
                IbiDataSegmentSize OFFSET(16) NUMBITS(8) [],
                /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
                RespBufThld OFFSET(8) NUMBITS(8) [],
                /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
                CmdEmptyBufThld OFFSET(0) NUMBITS(8) [],
            ],
            pub RecoveryCtrl [
                /// * 0-255: Selects a component memory space where the recovery image is. 0 is the default
                Cms OFFSET(0) NUMBITS(8) [],
                /// * 0x0: No operation
                ///
                /// * 0x1: Use Recovery Image from memory window (CMS)
                ///
                /// * 0x2: Use Recovery Image stored on device (C-image)
                ///
                /// * 0x3-FF: reserved
                RecImgSel OFFSET(8) NUMBITS(8) [],
                /// * 0x0: do not activate recovery image - after activation device will report this code.
                ///
                /// * 0xF: Activate recovery image
                ///
                /// * 0x10-FF-reserved
                ActivateRecImg OFFSET(16) NUMBITS(8) [],
            ],
            pub RecoveryStatus [
                /// * 0x0: Not in recovery mode
                ///
                /// * 0x1: Awaiting recovery image
                ///
                /// * 0x2: Booting recovery image
                ///
                /// * 0x3: Recovery successful
                ///
                /// * 0xc: Recovery failed
                ///
                /// * 0xd: Recovery image authentication error
                ///
                /// * 0xe: Error entering Recovery mode (might be administratively disabled)
                ///
                /// * 0xf: Invalid component address space
                DevRecStatus OFFSET(0) NUMBITS(4) [],
                RecImgIndex OFFSET(4) NUMBITS(4) [],
                VendorSpecificStatus OFFSET(8) NUMBITS(8) [],
            ],
            pub RecIntfCfg [
                /// Choose Recovery Interface access type:
                ///
                /// * 0 - I3C Core
                ///
                /// * 1 - direct AXI
                RecIntfBypass OFFSET(0) NUMBITS(1) [],
                /// Inform Recovery Handler that payload transfer is finished.
                RecPayloadDone OFFSET(1) NUMBITS(1) [],
            ],
            pub RecIntfRegW1cAccess [
                /// Write to 'Reset control - Device Reset Control' register, mocking a hardware access (bypassing 'write 1 to clear' register property).
                DeviceResetCtrl OFFSET(0) NUMBITS(8) [],
                /// Write to 'Recovery Control - Activate Recovery Image' register, mocking a hardware access (bypassing 'write 1 to clear' register property).
                RecoveryCtrlActivateRecImg OFFSET(8) NUMBITS(8) [],
                /// Write to 'Indirect memory configuration - reset' register, mocking a hardware access (bypassing 'write 1 to clear' register property).
                IndirectFifoCtrlReset OFFSET(16) NUMBITS(8) [],
            ],
            pub ResetControl [
                /// Clear IBI queue from software. Valid only in PIO mode.
                IbiQueueRst OFFSET(5) NUMBITS(1) [],
                /// Clear RX FIFO from software. Valid only in PIO mode.
                RxFifoRst OFFSET(4) NUMBITS(1) [],
                /// Clear TX FIFO from software. Valid only in PIO mode.
                TxFifoRst OFFSET(3) NUMBITS(1) [],
                /// Clear response queue from software. Valid only in PIO mode.
                RespQueueRst OFFSET(2) NUMBITS(1) [],
                /// Clear command queue from software. Valid only in PIO mode.
                CmdQueueRst OFFSET(1) NUMBITS(1) [],
                /// Reset controller from software.
                SoftRst OFFSET(0) NUMBITS(1) [],
            ],
            pub RingHeadersSectionOffset [
                /// DMA ring headers section offset. Invalid if 0.
                SectionOffset OFFSET(0) NUMBITS(16) [],
            ],
            pub SocPadAttr [
                /// Select driver strength
                ///
                /// '0 - lowest
                ///
                /// '1 - highest
                DriveStrength OFFSET(24) NUMBITS(8) [],
                /// Select driver slew rate
                ///
                /// '0 - lowest
                ///
                /// '1 - highest
                DriveSlewRate OFFSET(8) NUMBITS(8) [],
            ],
            pub SocPadConf [
                /// Select pad type
                ///
                /// 0 - Bidirectional
                ///
                /// 1 - Open-drain
                ///
                /// 2 - Input-only
                ///
                /// 3 - Analog input
                PadType OFFSET(24) NUMBITS(8) [],
                /// Enable virtual open drain:
                ///
                /// 0 - disabled
                ///
                /// 1 - enabled
                VirtualOdEn OFFSET(7) NUMBITS(1) [],
                /// Enable Open-Drain:
                ///
                /// 0 - disabled
                ///
                /// 1 - enabled
                OdEn OFFSET(6) NUMBITS(1) [],
                /// Invert I/O signal:
                ///
                /// 0 - signals pass-through
                ///
                /// 1 - signals are inverted
                IoInversion OFFSET(5) NUMBITS(1) [],
                /// Enable Pull:
                ///
                /// 0 - disabled
                ///
                /// 1 - enabled
                PullEn OFFSET(4) NUMBITS(1) [],
                /// Direction of the pull:
                ///
                /// 0 - Pull down
                ///
                /// 1 - Pull up
                PullDir OFFSET(3) NUMBITS(1) [],
                /// Enable the High-Keeper:
                ///
                /// 0 - disabled
                ///
                /// 1 - enabled
                KeeperEn OFFSET(2) NUMBITS(1) [],
                /// Enable the Schmitt Trigger:
                ///
                /// 0 - disabled
                ///
                /// 1 - enabled
                SchmittEn OFFSET(1) NUMBITS(1) [],
                /// Enable input:
                ///
                /// 0 - enabled
                ///
                /// 1 - disabled
                InputEnable OFFSET(0) NUMBITS(1) [],
            ],
            pub Status [
                /// Status of last IBI. Should be read after IBI_DONE interrupt.
                ///
                /// Values:
                ///
                /// 00 - Success: IBI was transmitted and ACK'd by the Active Controller.
                /// 01 - Failure: Active Controller NACK'd the IBI before any data was sent.
                /// The Target Device will retry sending the IBI once.
                /// 10 - Failure: Active Controller NACK'd the IBI after partial data was sent.
                /// Part of data in the IBI queue is considered corrupted and will be discarded.
                /// 11 - Failure: IBI was terminated after 1 retry.
                LastIbiStatus OFFSET(14) NUMBITS(2) [],
                /// Protocol error occurred in the past. This field can only be reset
                /// by the Controller, if it issues the GETSTATUS CCC.
                ///
                /// Values:
                ///
                /// 0 - no error occurred
                ///
                /// 1 - generic protocol error occurred in the past. It will be set until reception
                /// of the next GETSTATUS command.
                ProtocolError OFFSET(13) NUMBITS(1) [],
            ],
            pub StbyCrCapabilities [
                /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
                ///
                /// 1'b0: DISABLED: Not supported
                ///
                /// 1'b1: ENABLED: Supported
                DaaEntdaaSupport OFFSET(15) NUMBITS(1) [],
                ///  Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
                ///
                /// 1'b0: DISABLED: Not supported
                ///
                /// 1'b1: ENABLED: Supported
                DaaSetdasaSupport OFFSET(14) NUMBITS(1) [],
                /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
                ///
                /// 1'b0: DISABLED: Not supported
                ///
                /// 1'b1: ENABLED: Supported
                DaaSetaasaSupport OFFSET(13) NUMBITS(1) [],
                /// Defines whether an I3C Target Transaction Interface is supported.
                ///
                /// 1'b0: DISABLED: Not supported
                ///
                /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
                TargetXactSupport OFFSET(12) NUMBITS(1) [],
                SimpleCrrSupport OFFSET(5) NUMBITS(1) [],
            ],
            pub StbyCrCccConfigGetcaps [
                F2Crcap2DevInteract OFFSET(8) NUMBITS(4) [],
                F2Crcap1BusConfig OFFSET(0) NUMBITS(3) [],
            ],
            pub StbyCrCccConfigRstactParams [
                /// If set to 1'b1, then the Secondary Controller Logic must clear its Dynamic
                /// Address in register STBY_CR_DEVICE_ADDR after receiving
                /// a Target Reset Pattern that followed a Broadcast or Direct SET RSTACT CCC sent
                /// to the Dynamic Address, with Defining Byte 0x01 or 0x02.
                /// Requires support for Dynamic Address Assignment with at least one supported
                /// method, such as the ENTDAA CCC, with field DAA_ENTDAA_ENABLE set to 1'b1 in
                /// register STBY_CR_CONTROL.
                /// If field ACR_FSM_OP_SELECT in register STBY_CR_CONTROL is set to 1'b1, then
                /// this field shall be cleared (i.e., readiness to accept the Controller Role
                /// shall be revoked) with this Target Reset Pattern.
                ResetDynamicAddr OFFSET(31) NUMBITS(1) [],
                /// For Direct GET CCC, this field is returned for Defining Byte 0x82.
                ResetTimeTarget OFFSET(16) NUMBITS(8) [],
                /// For Direct GET CCC, this field is returned for Defining Byte 0x81.
                ResetTimePeripheral OFFSET(8) NUMBITS(8) [],
                /// Contains the Defining Byte received with the last Direct SET CCC sent by the Active Controller.
                RstAction OFFSET(0) NUMBITS(8) [],
            ],
            pub StbyCrControl [
                /// Enables or disables the Secondary Controller:
                ///
                /// 2'b00 - DISABLED: Secondary Controller is disabled.
                ///
                /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
                /// but Host Controller initializes in Active Controller mode.
                ///
                /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
                /// Host Controller initializes in Standby Controller mode.
                ///
                /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
                /// Host Controller conditionally becomes a Hot-Joining Device
                /// to receive its Dynamic Address before operating in Standby Controller mode.
                StbyCrEnableInit OFFSET(30) NUMBITS(2) [],
                /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
                /// Defining Byte 0x02.
                ///
                /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
                ///
                /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
                RstactDefbyte02 OFFSET(20) NUMBITS(1) [],
                ///
                /// Indicates ENTDAA method is enabled.
                ///
                /// 1'b0: DISABLED: will not respond
                ///
                /// 1'b1: ENABLED: will respond
                DaaEntdaaEnable OFFSET(15) NUMBITS(1) [],
                ///
                /// Indicates SETDASA method is enabled.
                ///
                /// 1'b0: DISABLED: will not respond
                ///
                /// 1'b1: ENABLED: will respond
                DaaSetdasaEnable OFFSET(14) NUMBITS(1) [],
                ///
                /// Indicates SETAASA method is enabled.
                ///
                /// 1'b0: DISABLED: will not respond
                ///
                /// 1'b1: ENABLED: will respond
                DaaSetaasaEnable OFFSET(13) NUMBITS(1) [],
                /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
                /// an I3C Target Transaction Interface to software (Section 6.17.3).
                ///
                /// 1'b0: DISABLED: not available
                ///
                /// 1'b1: ENABLED: available for software
                TargetXactEnable OFFSET(12) NUMBITS(1) [],
                /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
                /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
                BastCccIbiRing OFFSET(8) NUMBITS(3) [],
                /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
                /// to attempt to send a Controller Role Request to the I3C Bus.
                CrRequestSend OFFSET(5) NUMBITS(1) [],
                /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
                /// report a return from Deep Sleep state to the Active Controller.
                /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
                /// after accepting the Controller Role and transitioning to Active Controller mode.
                HandoffDeepSleep OFFSET(4) NUMBITS(1) [],
                PrimeAcceptGetacccr OFFSET(3) NUMBITS(1) [],
                AcrFsmOpSelect OFFSET(2) NUMBITS(1) [],
                HandoffDelayNack OFFSET(1) NUMBITS(1) [],
                PendingRxNack OFFSET(0) NUMBITS(1) [],
            ],
            pub StbyCrDeviceAddr [
                /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
                /// 1'b0: DYNAMIC_ADDR field is not valid
                /// 1'b1: DYNAMIC_ADDR field is valid
                DynamicAddrValid OFFSET(31) NUMBITS(1) [],
                /// Contains the Host Controller Device’s Dynamic Address.
                DynamicAddr OFFSET(16) NUMBITS(7) [],
                /// Indicates whether or not the value in the STATIC_ADDR field is valid.
                ///
                /// 1'b0: The Static Address field is not valid
                ///
                /// 1'b1: The Static Address field is valid
                StaticAddrValid OFFSET(15) NUMBITS(1) [],
                /// This field contains the Host Controller Device’s Static Address.
                StaticAddr OFFSET(0) NUMBITS(7) [],
            ],
            pub StbyCrDeviceChar [
                /// Bus Characteristics, Fixed Part.
                ///
                /// Reset value is set to 3'b001, because this device is an I3C Target,
                /// which supports extended capabilities
                BcrFixed OFFSET(29) NUMBITS(3) [],
                /// Bus Characteristics, Variable Part.
                ///
                /// Reset value is set to 5'b00110, because this device:
                ///
                ///
                /// - [bit4] is not a Virtual  Target
                ///
                /// - [bit3] is not Offline Capable
                ///
                /// - [bit2] uses the MDB in the IBI Payload
                ///
                /// - [bit1] is capable of IBI requests
                ///
                /// - [bit0] has no speed limitation
                BcrVar OFFSET(24) NUMBITS(5) [],
                /// Device Characteristics Register. Value represents an OCP Recovery Device.
                Dcr OFFSET(16) NUMBITS(8) [],
                /// High part of the 48-bit Target Device Provisioned ID.
                PidHi OFFSET(1) NUMBITS(15) [],
            ],
            pub StbyCrIntrForce [
                CccFatalRstdaaErrForce OFFSET(19) NUMBITS(1) [],
                CccUnhandledNackForce OFFSET(18) NUMBITS(1) [],
                CccParamModifiedForce OFFSET(17) NUMBITS(1) [],
                StbyCrOpRstactForce OFFSET(16) NUMBITS(1) [],
                StbyCrAcceptErrForce OFFSET(14) NUMBITS(1) [],
                StbyCrAcceptOkForce OFFSET(13) NUMBITS(1) [],
                StbyCrAcceptNackedForce OFFSET(12) NUMBITS(1) [],
                StbyCrDynAddrForce OFFSET(11) NUMBITS(1) [],
                CrrResponseForce OFFSET(10) NUMBITS(1) [],
            ],
            pub StbyCrIntrSignalEnable [
                CccFatalRstdaaErrSignalEn OFFSET(19) NUMBITS(1) [],
                CccUnhandledNackSignalEn OFFSET(18) NUMBITS(1) [],
                CccParamModifiedSignalEn OFFSET(17) NUMBITS(1) [],
                StbyCrOpRstactSignalEn OFFSET(16) NUMBITS(1) [],
                StbyCrAcceptErrSignalEn OFFSET(14) NUMBITS(1) [],
                StbyCrAcceptOkSignalEn OFFSET(13) NUMBITS(1) [],
                StbyCrAcceptNackedSignalEn OFFSET(12) NUMBITS(1) [],
                StbyCrDynAddrSignalEn OFFSET(11) NUMBITS(1) [],
                CrrResponseSignalEn OFFSET(10) NUMBITS(1) [],
                AcrHandoffErrM3SignalEn OFFSET(3) NUMBITS(1) [],
                AcrHandoffErrFailSignalEn OFFSET(2) NUMBITS(1) [],
                AcrHandoffOkPrimedSignalEn OFFSET(1) NUMBITS(1) [],
                AcrHandoffOkRemainSignalEn OFFSET(0) NUMBITS(1) [],
            ],
            pub StbyCrIntrStatus [
                CccFatalRstdaaErrStat OFFSET(19) NUMBITS(1) [],
                CccUnhandledNackStat OFFSET(18) NUMBITS(1) [],
                CccParamModifiedStat OFFSET(17) NUMBITS(1) [],
                /// The Host Controller shall write 1'b1 to this field to indicate that the
                /// Secondary Controller received a RSTACT CCC from the Active Controller, followed
                /// by the Target Reset Pattern.
                StbyCrOpRstactStat OFFSET(16) NUMBITS(1) [],
                StbyCrAcceptErrStat OFFSET(14) NUMBITS(1) [],
                StbyCrAcceptOkStat OFFSET(13) NUMBITS(1) [],
                StbyCrAcceptNackedStat OFFSET(12) NUMBITS(1) [],
                StbyCrDynAddrStat OFFSET(11) NUMBITS(1) [],
                CrrResponseStat OFFSET(10) NUMBITS(1) [],
                AcrHandoffErrM3Stat OFFSET(3) NUMBITS(1) [],
                AcrHandoffErrFailStat OFFSET(2) NUMBITS(1) [],
                AcrHandoffOkPrimedStat OFFSET(1) NUMBITS(1) [],
                AcrHandoffOkRemainStat OFFSET(0) NUMBITS(1) [],
            ],
            pub StbyCrStatus [
                HjReqStatus OFFSET(8) NUMBITS(1) [],
                SimpleCrrStatus OFFSET(5) NUMBITS(3) [],
                AcCurrentOwn OFFSET(2) NUMBITS(1) [],
            ],
            pub StbyCrVirtualDeviceChar [
                /// Bus Characteristics, Fixed Part.
                ///
                /// Reset value is set to 3'b001, because this device is an I3C Target,
                /// which supports extended capabilities
                BcrFixed OFFSET(29) NUMBITS(3) [],
                /// Bus Characteristics, Variable Part.
                ///
                /// Reset value is set to 5'b00110, because this device:
                ///
                ///
                /// - [bit4] is not a Virtual Target
                ///
                /// - [bit3] is not Offline Capable
                ///
                /// - [bit2] uses the MDB in the IBI Payload
                ///
                /// - [bit1] is capable of IBI requests
                ///
                /// - [bit0] has no speed limitation
                BcrVar OFFSET(24) NUMBITS(5) [],
                /// Device Characteristics Register. Value represents an OCP Recovery Device.
                Dcr OFFSET(16) NUMBITS(8) [],
                /// High part of the 48-bit Target Device Provisioned ID.
                PidHi OFFSET(1) NUMBITS(15) [],
            ],
            pub StbyCrVirtDeviceAddr [
                /// Indicates whether or not the value in the VIRT_DYNAMIC_ADDR field is valid.
                /// 1'b0: VIRT_DYNAMIC_ADDR field is not valid
                /// 1'b1: VIRT_DYNAMIC_ADDR field is valid
                VirtDynamicAddrValid OFFSET(31) NUMBITS(1) [],
                /// Contains the Controller Virtual Device’s Dynamic Address.
                VirtDynamicAddr OFFSET(16) NUMBITS(7) [],
                /// Indicates whether or not the value in the VIRT_STATIC_ADDR field is valid.
                ///
                /// 1'b0: The Virtual Device Static Address field is not valid
                ///
                /// 1'b1: The Virtual Device Static Address field is valid
                VirtStaticAddrValid OFFSET(15) NUMBITS(1) [],
                /// This field contains the Host Controller Device’s Static Address.
                VirtStaticAddr OFFSET(0) NUMBITS(7) [],
            ],
            pub TtiDataBufferThldCtrl [
                /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
                RxStartThld OFFSET(24) NUMBITS(3) [],
                /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
                TxStartThld OFFSET(16) NUMBITS(3) [],
                /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
                RxDataThld OFFSET(8) NUMBITS(3) [],
                /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
                TxDataThld OFFSET(0) NUMBITS(3) [],
            ],
            pub TtiQueueSize [
                /// Transmit Data Buffer Size in DWORDs calculated as `2^(N+1)`
                TxDataBufferSize OFFSET(24) NUMBITS(8) [],
                /// Receive Data Buffer Size in DWORDs calculated as `2^(N+1)`
                RxDataBufferSize OFFSET(16) NUMBITS(8) [],
                /// TX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
                TxDescBufferSize OFFSET(8) NUMBITS(8) [],
                /// RX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
                RxDescBufferSize OFFSET(0) NUMBITS(8) [],
            ],
            pub TtiQueueThldCtrl [
                /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
                IbiThld OFFSET(24) NUMBITS(8) [],
                /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
                RxDescThld OFFSET(8) NUMBITS(8) [],
                /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
                TxDescThld OFFSET(0) NUMBITS(8) [],
            ],
            pub TtiResetControl [
                /// TTI IBI Queue Buffer Software Reset
                IbiQueueRst OFFSET(5) NUMBITS(1) [],
                /// TTI RX Data Queue Buffer Software Reset
                RxDataRst OFFSET(4) NUMBITS(1) [],
                /// TTI TX Data Queue Buffer Software Reset
                TxDataRst OFFSET(3) NUMBITS(1) [],
                /// TTI RX Descriptor Queue Buffer Software Reset
                RxDescRst OFFSET(2) NUMBITS(1) [],
                /// TTI TX Descriptor Queue Buffer Software Reset
                TxDescRst OFFSET(1) NUMBITS(1) [],
                /// Target Core Software Reset
                SoftRst OFFSET(0) NUMBITS(1) [],
            ],
            pub TFReg [
                /// Fall time of both SDA and SCL in clock units
                TF OFFSET(0) NUMBITS(20) [],
            ],
            pub THdDatReg [
                /// Data hold time in clock units
                THdDat OFFSET(0) NUMBITS(20) [],
            ],
            pub THdStaReg [
                /// Hold time for (repeated) START in clock units
                THdSta OFFSET(0) NUMBITS(20) [],
            ],
            pub THighReg [
                THigh OFFSET(0) NUMBITS(20) [],
            ],
            pub TLowReg [
                /// Low period of the SCL in clock units
                TLow OFFSET(0) NUMBITS(20) [],
            ],
            pub TRReg [
                /// Rise time of both SDA and SCL in clock units
                TR OFFSET(0) NUMBITS(20) [],
            ],
            pub TSuDatReg [
                /// Data setup time in clock units
                TSuDat OFFSET(0) NUMBITS(20) [],
            ],
            pub TSuStaReg [
                /// Setup time for repeated START in clock units
                TSuSta OFFSET(0) NUMBITS(20) [],
            ],
            pub TSuStoReg [
                /// Setup time for STOP in clock units
                TSuSto OFFSET(0) NUMBITS(20) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub I3c {
            (0x0 => pub i3c_base_hci_version: tock_registers::registers::ReadOnly<u32>),
            (0x4 => pub i3c_base_hc_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::HcControl::Register>),
            (0x8 => pub i3c_base_controller_device_addr: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::ControllerDeviceAddr::Register>),
            (0xc => pub i3c_base_hc_capabilities: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::HcCapabilities::Register>),
            (0x10 => pub i3c_base_reset_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::ResetControl::Register>),
            (0x14 => pub i3c_base_present_state: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::PresentState::Register>),
            (0x18 => _reserved0),
            (0x20 => pub i3c_base_intr_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IntrStatus::Register>),
            (0x24 => pub i3c_base_intr_status_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IntrStatusEnable::Register>),
            (0x28 => pub i3c_base_intr_signal_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IntrSignalEnable::Register>),
            (0x2c => pub i3c_base_intr_force: tock_registers::registers::WriteOnly<u32, crate::i3c::bits::IntrForce::Register>),
            (0x30 => pub i3c_base_dat_section_offset: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::DatSectionOffset::Register>),
            (0x34 => pub i3c_base_dct_section_offset: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DctSectionOffset::Register>),
            (0x38 => pub i3c_base_ring_headers_section_offset: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::RingHeadersSectionOffset::Register>),
            (0x3c => pub i3c_base_pio_section_offset: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::PioSectionOffset::Register>),
            (0x40 => pub i3c_base_ext_caps_section_offset: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtCapsSectionOffset::Register>),
            (0x44 => _reserved1),
            (0x4c => pub i3c_base_int_ctrl_cmds_en: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::IntCtrlCmdsEn::Register>),
            (0x50 => _reserved2),
            (0x58 => pub i3c_base_ibi_notify_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IbiNotifyCtrl::Register>),
            (0x5c => pub i3c_base_ibi_data_abort_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IbiDataAbortCtrl::Register>),
            (0x60 => pub i3c_base_dev_ctx_base_lo: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DevCtxBaseLo::Register>),
            (0x64 => pub i3c_base_dev_ctx_base_hi: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DevCtxBaseHi::Register>),
            (0x68 => pub i3c_base_dev_ctx_sg: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::DevCtxSg::Register>),
            (0x6c => _reserved3),
            (0x80 => pub piocontrol_command_port: tock_registers::registers::WriteOnly<u32>),
            (0x84 => pub piocontrol_response_port: tock_registers::registers::ReadOnly<u32>),
            (0x88 => pub piocontrol_tx_data_port: tock_registers::registers::WriteOnly<u32>),
            (0x8c => pub piocontrol_ibi_port: tock_registers::registers::ReadOnly<u32>),
            (0x90 => pub piocontrol_queue_thld_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::QueueThldCtrl::Register>),
            (0x94 => pub piocontrol_data_buffer_thld_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DataBufferThldCtrl::Register>),
            (0x98 => pub piocontrol_queue_size: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::QueueSize::Register>),
            (0x9c => pub piocontrol_alt_queue_size: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::AltQueueSize::Register>),
            (0xa0 => pub piocontrol_pio_intr_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::PioIntrStatus::Register>),
            (0xa4 => pub piocontrol_pio_intr_status_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::PioIntrStatusEnable::Register>),
            (0xa8 => pub piocontrol_pio_intr_signal_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::PioIntrSignalEnable::Register>),
            (0xac => pub piocontrol_pio_intr_force: tock_registers::registers::WriteOnly<u32, crate::i3c::bits::PioIntrForce::Register>),
            (0xb0 => pub piocontrol_pio_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::PioControl::Register>),
            (0xb4 => _reserved4),
            (0x100 => pub i3c_ec_termination_extcap_header: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtcapHeader::Register>),
            (0x104 => pub sec_fw_recovery_if_prot_cap_0: tock_registers::registers::ReadOnly<u32>),
            (0x108 => pub sec_fw_recovery_if_prot_cap_1: tock_registers::registers::ReadOnly<u32>),
            (0x10c => pub sec_fw_recovery_if_prot_cap_2: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::ProtCap2::Register>),
            (0x110 => pub sec_fw_recovery_if_prot_cap_3: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::ProtCap3::Register>),
            (0x114 => pub sec_fw_recovery_if_device_id_0: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DeviceId0::Register>),
            (0x118 => pub sec_fw_recovery_if_device_id_1: tock_registers::registers::ReadWrite<u32>),
            (0x11c => pub sec_fw_recovery_if_device_id_2: tock_registers::registers::ReadWrite<u32>),
            (0x120 => pub sec_fw_recovery_if_device_id_3: tock_registers::registers::ReadWrite<u32>),
            (0x124 => pub sec_fw_recovery_if_device_id_4: tock_registers::registers::ReadWrite<u32>),
            (0x128 => pub sec_fw_recovery_if_device_id_5: tock_registers::registers::ReadWrite<u32>),
            (0x12c => pub sec_fw_recovery_if_device_id_reserved: tock_registers::registers::ReadOnly<u32>),
            (0x130 => pub sec_fw_recovery_if_device_status_0: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DeviceStatus0::Register>),
            (0x134 => pub sec_fw_recovery_if_device_status_1: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DeviceStatus1::Register>),
            (0x138 => pub sec_fw_recovery_if_device_reset: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::DeviceReset::Register>),
            (0x13c => pub sec_fw_recovery_if_recovery_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::RecoveryCtrl::Register>),
            (0x140 => pub sec_fw_recovery_if_recovery_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::RecoveryStatus::Register>),
            (0x144 => pub sec_fw_recovery_if_hw_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::HwStatus::Register>),
            (0x148 => pub sec_fw_recovery_if_indirect_fifo_ctrl_0: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::IndirectFifoCtrl0::Register>),
            (0x14c => pub sec_fw_recovery_if_indirect_fifo_ctrl_1: tock_registers::registers::ReadWrite<u32>),
            (0x150 => pub sec_fw_recovery_if_indirect_fifo_status_0: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::IndirectFifoStatus0::Register>),
            (0x154 => pub sec_fw_recovery_if_indirect_fifo_status_1: tock_registers::registers::ReadOnly<u32>),
            (0x158 => pub sec_fw_recovery_if_indirect_fifo_status_2: tock_registers::registers::ReadOnly<u32>),
            (0x15c => pub sec_fw_recovery_if_indirect_fifo_status_3: tock_registers::registers::ReadOnly<u32>),
            (0x160 => pub sec_fw_recovery_if_indirect_fifo_status_4: tock_registers::registers::ReadOnly<u32>),
            (0x164 => pub sec_fw_recovery_if_indirect_fifo_reserved: tock_registers::registers::ReadOnly<u32>),
            (0x168 => pub sec_fw_recovery_if_indirect_fifo_data: tock_registers::registers::ReadOnly<u32>),
            (0x16c => _reserved5),
            (0x180 => pub stdby_ctrl_mode_extcap_header: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtcapHeader::Register>),
            (0x184 => pub stdby_ctrl_mode_stby_cr_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrControl::Register>),
            (0x188 => pub stdby_ctrl_mode_stby_cr_device_addr: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrDeviceAddr::Register>),
            (0x18c => pub stdby_ctrl_mode_stby_cr_capabilities: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::StbyCrCapabilities::Register>),
            (0x190 => pub stdby_ctrl_mode_stby_cr_virtual_device_char: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrVirtualDeviceChar::Register>),
            (0x194 => pub stdby_ctrl_mode_stby_cr_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrStatus::Register>),
            (0x198 => pub stdby_ctrl_mode_stby_cr_device_char: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrDeviceChar::Register>),
            (0x19c => pub stdby_ctrl_mode_stby_cr_device_pid_lo: tock_registers::registers::ReadWrite<u32>),
            (0x1a0 => pub stdby_ctrl_mode_stby_cr_intr_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrIntrStatus::Register>),
            (0x1a4 => pub stdby_ctrl_mode_stby_cr_virtual_device_pid_lo: tock_registers::registers::ReadWrite<u32>),
            (0x1a8 => pub stdby_ctrl_mode_stby_cr_intr_signal_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrIntrSignalEnable::Register>),
            (0x1ac => pub stdby_ctrl_mode_stby_cr_intr_force: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrIntrForce::Register>),
            (0x1b0 => pub stdby_ctrl_mode_stby_cr_ccc_config_getcaps: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrCccConfigGetcaps::Register>),
            (0x1b4 => pub stdby_ctrl_mode_stby_cr_ccc_config_rstact_params: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrCccConfigRstactParams::Register>),
            (0x1b8 => pub stdby_ctrl_mode_stby_cr_virt_device_addr: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::StbyCrVirtDeviceAddr::Register>),
            (0x1bc => pub stdby_ctrl_mode_rsvd_3: tock_registers::registers::ReadWrite<u32>),
            (0x1c0 => pub tti_extcap_header: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtcapHeader::Register>),
            (0x1c4 => pub tti_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::Control::Register>),
            (0x1c8 => pub tti_status: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::Status::Register>),
            (0x1cc => pub tti_tti_reset_control: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TtiResetControl::Register>),
            (0x1d0 => pub tti_interrupt_status: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::InterruptStatus::Register>),
            (0x1d4 => pub tti_interrupt_enable: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::InterruptEnable::Register>),
            (0x1d8 => pub tti_interrupt_force: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::InterruptForce::Register>),
            (0x1dc => pub tti_rx_desc_queue_port: tock_registers::registers::ReadOnly<u32>),
            (0x1e0 => pub tti_rx_data_port: tock_registers::registers::ReadOnly<u32>),
            (0x1e4 => pub tti_tx_desc_queue_port: tock_registers::registers::WriteOnly<u32>),
            (0x1e8 => pub tti_tx_data_port: tock_registers::registers::WriteOnly<u32>),
            (0x1ec => pub tti_tti_ibi_port: tock_registers::registers::WriteOnly<u32>),
            (0x1f0 => pub tti_tti_queue_size: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::TtiQueueSize::Register>),
            (0x1f4 => pub tti_ibi_tti_queue_size: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::IbiTtiQueueSize::Register>),
            (0x1f8 => pub tti_tti_queue_thld_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TtiQueueThldCtrl::Register>),
            (0x1fc => pub tti_tti_data_buffer_thld_ctrl: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TtiDataBufferThldCtrl::Register>),
            (0x200 => pub soc_mgmt_if_extcap_header: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtcapHeader::Register>),
            (0x204 => pub soc_mgmt_if_soc_mgmt_control: tock_registers::registers::ReadWrite<u32>),
            (0x208 => pub soc_mgmt_if_soc_mgmt_status: tock_registers::registers::ReadWrite<u32>),
            (0x20c => pub soc_mgmt_if_rec_intf_cfg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::RecIntfCfg::Register>),
            (0x210 => pub soc_mgmt_if_rec_intf_reg_w1_c_access: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::RecIntfRegW1cAccess::Register>),
            (0x214 => pub soc_mgmt_if_soc_mgmt_rsvd_2: tock_registers::registers::ReadWrite<u32>),
            (0x218 => pub soc_mgmt_if_soc_mgmt_rsvd_3: tock_registers::registers::ReadWrite<u32>),
            (0x21c => pub soc_mgmt_if_soc_pad_conf: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::SocPadConf::Register>),
            (0x220 => pub soc_mgmt_if_soc_pad_attr: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::SocPadAttr::Register>),
            (0x224 => pub soc_mgmt_if_soc_mgmt_feature_2: tock_registers::registers::ReadWrite<u32>),
            (0x228 => pub soc_mgmt_if_soc_mgmt_feature_3: tock_registers::registers::ReadWrite<u32>),
            (0x22c => pub soc_mgmt_if_t_r_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TRReg::Register>),
            (0x230 => pub soc_mgmt_if_t_f_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TFReg::Register>),
            (0x234 => pub soc_mgmt_if_t_su_dat_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TSuDatReg::Register>),
            (0x238 => pub soc_mgmt_if_t_hd_dat_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::THdDatReg::Register>),
            (0x23c => pub soc_mgmt_if_t_high_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::THighReg::Register>),
            (0x240 => pub soc_mgmt_if_t_low_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TLowReg::Register>),
            (0x244 => pub soc_mgmt_if_t_hd_sta_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::THdStaReg::Register>),
            (0x248 => pub soc_mgmt_if_t_su_sta_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TSuStaReg::Register>),
            (0x24c => pub soc_mgmt_if_t_su_sto_reg: tock_registers::registers::ReadWrite<u32, crate::i3c::bits::TSuStoReg::Register>),
            (0x250 => pub soc_mgmt_if_t_free_reg: tock_registers::registers::ReadWrite<u32>),
            (0x254 => pub soc_mgmt_if_t_aval_reg: tock_registers::registers::ReadWrite<u32>),
            (0x258 => pub soc_mgmt_if_t_idle_reg: tock_registers::registers::ReadWrite<u32>),
            (0x25c => _reserved6),
            (0x260 => pub ctrl_cfg_extcap_header: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ExtcapHeader::Register>),
            (0x264 => pub ctrl_cfg_controller_config: tock_registers::registers::ReadOnly<u32, crate::i3c::bits::ControllerConfig::Register>),
            (0x268 => _reserved7),
            (0x400 => pub dat: [tock_registers::registers::ReadWrite<u32>; 256]),
            (0x800 => pub dct: [tock_registers::registers::ReadWrite<u32>; 512]),
            (0x1000 => @END),
        }
    }
}
