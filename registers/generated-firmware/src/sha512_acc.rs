// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at fb99e5f5aadf5685badae3ea453e72b55be9328c
//
pub const SHA512_ACC_CSR_ADDR: u32 = 0xa002_1000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub Control [
                /// Zeroize all internal registers
                Zeroize OFFSET(0) NUMBITS(1) [],
            ],
            pub Execute [
                Execute OFFSET(0) NUMBITS(1) [],
            ],
            pub Lock [
                Lock OFFSET(0) NUMBITS(1) [],
            ],
            pub Mode [
                Mode OFFSET(0) NUMBITS(2) [
                    ShaStream384 = 0,
                    ShaStream512 = 1,
                    ShaMbox384 = 2,
                    ShaMbox512 = 3,
                ],
                /// Default behavior assumes that data in mailbox or from streaming input is little endian,
                /// When set to 0, data input (from mailbox or streaming data) will be swizzled from little to big endian at the byte level.
                /// When set to 1, data input will be loaded into SHA as-is.
                /// [br]Caliptra Access: RW
                /// [br]SOC Access:      RW
                EndianToggle OFFSET(2) NUMBITS(1) [],
            ],
            pub Status [
                /// Valid bit, indicating that the digest is complete
                Valid OFFSET(0) NUMBITS(1) [],
                /// Indicates that the current lock was acquired by the SoC
                SocHasLock OFFSET(1) NUMBITS(1) [],
            ],
            pub ErrorIntrEnT [
                /// Enable bit for Event 0
                Error0En OFFSET(0) NUMBITS(1) [],
                /// Enable bit for Event 1
                Error1En OFFSET(1) NUMBITS(1) [],
                /// Enable bit for Event 2
                Error2En OFFSET(2) NUMBITS(1) [],
                /// Enable bit for Event 3
                Error3En OFFSET(3) NUMBITS(1) [],
            ],
            pub ErrorIntrT [
                /// Interrupt Event 0 status bit
                Error0Sts OFFSET(0) NUMBITS(1) [],
                /// Interrupt Event 1 status bit
                Error1Sts OFFSET(1) NUMBITS(1) [],
                /// Interrupt Event 2 status bit
                Error2Sts OFFSET(2) NUMBITS(1) [],
                /// Interrupt Event 3 status bit
                Error3Sts OFFSET(3) NUMBITS(1) [],
            ],
            pub ErrorIntrTrigT [
                /// Interrupt Trigger 0 bit
                Error0Trig OFFSET(0) NUMBITS(1) [],
                /// Interrupt Trigger 1 bit
                Error1Trig OFFSET(1) NUMBITS(1) [],
                /// Interrupt Trigger 2 bit
                Error2Trig OFFSET(2) NUMBITS(1) [],
                /// Interrupt Trigger 3 bit
                Error3Trig OFFSET(3) NUMBITS(1) [],
            ],
            pub GlobalIntrEnT [
                /// Global enable bit for all events of type 'Error'
                ErrorEn OFFSET(0) NUMBITS(1) [],
                /// Global enable bit for all events of type 'Notification'
                NotifEn OFFSET(1) NUMBITS(1) [],
            ],
            pub GlobalIntrT [
                /// Interrupt Event Aggregation status bit
                AggSts OFFSET(0) NUMBITS(1) [],
            ],
            pub IntrCountIncrT [
                /// Pulse mirrors interrupt event occurrence
                Pulse OFFSET(0) NUMBITS(1) [],
            ],
            pub NotifIntrEnT [
                /// Enable bit for Command Done Interrupt
                NotifCmdDoneEn OFFSET(0) NUMBITS(1) [],
            ],
            pub NotifIntrT [
                /// Command Done Interrupt status bit
                NotifCmdDoneSts OFFSET(0) NUMBITS(1) [],
            ],
            pub NotifIntrTrigT [
                /// Interrupt Trigger 0 bit
                NotifCmdDoneTrig OFFSET(0) NUMBITS(1) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub Sha512Acc {
            (0x0 => pub lock: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::Lock::Register>),
            (0x4 => pub user: tock_registers::registers::ReadOnly<u32>),
            (0x8 => pub mode: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::Mode::Register>),
            (0xc => pub start_address: tock_registers::registers::ReadWrite<u32>),
            (0x10 => pub dlen: tock_registers::registers::ReadWrite<u32>),
            (0x14 => pub datain: tock_registers::registers::ReadWrite<u32>),
            (0x18 => pub execute: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::Execute::Register>),
            (0x1c => pub status: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::Status::Register>),
            (0x20 => pub digest: [tock_registers::registers::ReadOnly<u32>; 16]),
            (0x60 => pub control: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::Control::Register>),
            (0x64 => _reserved0),
            (0x800 => pub intr_block_rf_global_intr_en_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::GlobalIntrEnT::Register>),
            (0x804 => pub intr_block_rf_error_intr_en_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::ErrorIntrEnT::Register>),
            (0x808 => pub intr_block_rf_notif_intr_en_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::NotifIntrEnT::Register>),
            (0x80c => pub intr_block_rf_error_global_intr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::GlobalIntrT::Register>),
            (0x810 => pub intr_block_rf_notif_global_intr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::GlobalIntrT::Register>),
            (0x814 => pub intr_block_rf_error_internal_intr_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::ErrorIntrT::Register>),
            (0x818 => pub intr_block_rf_notif_internal_intr_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::NotifIntrT::Register>),
            (0x81c => pub intr_block_rf_error_intr_trig_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::ErrorIntrTrigT::Register>),
            (0x820 => pub intr_block_rf_notif_intr_trig_r: tock_registers::registers::ReadWrite<u32, crate::sha512_acc::bits::NotifIntrTrigT::Register>),
            (0x824 => _reserved1),
            (0x900 => pub intr_block_rf_error0_intr_count_r: tock_registers::registers::ReadWrite<u32>),
            (0x904 => pub intr_block_rf_error1_intr_count_r: tock_registers::registers::ReadWrite<u32>),
            (0x908 => pub intr_block_rf_error2_intr_count_r: tock_registers::registers::ReadWrite<u32>),
            (0x90c => pub intr_block_rf_error3_intr_count_r: tock_registers::registers::ReadWrite<u32>),
            (0x910 => _reserved2),
            (0x980 => pub intr_block_rf_notif_cmd_done_intr_count_r: tock_registers::registers::ReadWrite<u32>),
            (0x984 => _reserved3),
            (0xa00 => pub intr_block_rf_error0_intr_count_incr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::IntrCountIncrT::Register>),
            (0xa04 => pub intr_block_rf_error1_intr_count_incr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::IntrCountIncrT::Register>),
            (0xa08 => pub intr_block_rf_error2_intr_count_incr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::IntrCountIncrT::Register>),
            (0xa0c => pub intr_block_rf_error3_intr_count_incr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::IntrCountIncrT::Register>),
            (0xa10 => pub intr_block_rf_notif_cmd_done_intr_count_incr_r: tock_registers::registers::ReadOnly<u32, crate::sha512_acc::bits::IntrCountIncrT::Register>),
            (0xa14 => @END),
        }
    }
}
